<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimal-ui">
    <title><%= title %></title>
    <script src="/javascripts/jquery.min.js"></script>
    <link rel='stylesheet' href='/stylesheets/jquery.textcomplete.css' />
    <link rel="stylesheet" href="/stylesheets/jquery-ui.min.css">
    <link rel='stylesheet' href='/stylesheets/style.css' />
    <link rel="stylesheet" href="/stylesheets/side-menu.css">
    <link rel='stylesheet' href='/stylesheets/jquery.taghandler.css' />
    <link rel='stylesheet' href='/stylesheets/jquery.content-panel-switcher.css' />
    <script src="/javascripts/jquery.content-panel-switcher.js"></script>
    <link rel="stylesheet" type="text/css" href="/stylesheets/tooltipster.css" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/tooltipster-noir.css" />
    <% if (speech) { %>
    <script src="/javascripts/talkify.min.js"></script>
    <%  } %>
    <% if (locals.user) { %>
        <% if (locals.user.midi != undefined && locals.user.midi != 'off') { %>
    <script src="/javascripts/webmidi.min.js"></script>
          <%  } %>
    <%  } %>
    <link rel="stylesheet" href="/stylesheets/bootstrap-tour-standalone.min.css" />
    <script src="/javascripts/bootstrap-tour-standalone.min.js"></script>




</head>
<body>
<% include statsabove %>
<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link editorpane">
    <!-- Hamburger icon -->
    <span></span>
    </a>
     <div id="menu">
        <div class="pure-menu pure-menu-open">
        <% if (locals.user || perceivername) { %>
            <% if (perceivername) { %>
            <a class="pure-menu-heading" href="/<%= perceivername %>"><%= perceivername %></a>
            <% } else { %>
            <a class="pure-menu-heading" href="/apps"><%= user.name %></a>
            <% } %>
                <br>
                <ul id="contexts" class="contexts">

                </ul>
            &nbsp;<br><br>

        <% } else { %>
            <% include menu %>

        <% } %>
        </div>
   </div>
     <div id='content'>

             <div id='statements'>

               <div id='topnav'>
                 <div class='pure-menu pure-menu-open pure-menu-horizontal'>
                   <ul id='topnav_items'>
                        <li id="summary">
                             <a>Essence</a>
                        </li>
                       <li  id="overview" class="pure-menu-selected-top">
                           <a>Overview</a>
                       </li>
                       <li id="insight">
                            <a>Insight</a>
                       </li>

                  </ul>
                </div>

                </div>

                 <div id="entries">

                     <div id="explanation"></div>

                     <% entries.forEach(function(entry) { %>
                     <div class='entry' data-uid='<%= entry.uid %>' data-timestamp='<%= entry.timestamp %>' data-hashtags='<%= entry.name %>'>
                         <p class='entry-text'><%- entry.text %></p>
                         <p class='entry-date'><%= entry.timestamp %></p>
                         <p class='entry-menu'>&nbsp;&nbsp;&nbsp;<a class="app-link-menu" href="#">show filtered</a></p>
                         <div class='separator'>&nbsp;</div>
                         <div id='<%= entry.uid %>' class='hidden'></div>
                     </div>
                     <% }) %>


                     <% include messages %>
                     <div id="warnings"></div>

             </div>

             <div id="entryform" class="editorpane">




       <% if (!perceivername) { %>

            <div id='switcher-selector' class='pure-menu pure-menu-open pure-menu-horizontal' style="background: none;">
                <ul id="topmenuitems">


                    <% if (!addcontext) {%>
                      <li>
                          <a id="finds" class="switcher set1">find</a>
                      </li>
                    <li class="pure-menu-selected-top">
                        <a id="adds" class="switcher set1">edit</a>
                    </li>
                    <li>
                        <a id="imports" href="/<%= user.name %>/meta_<%= context %>/edit?addcontext=<%= context %>&interpret=1">interpret</a>
                    </li>
                    <% } else { %>

                      <li>
                          <a id="imports" href="/<%= user.name %>/<%= addcontext %>/edit">original</a>
                      </li>
                      <li class="pure-menu-selected-top">
                          <a id="adds" class="switcher set1">interpret</a>
                      </li>
                      <li>
                          <a id="finds" href="/<%= user.name %>/<%= context %>/edit">result</a>
                      </li>



                    <% } %>



                </ul>

                <br>&nbsp;<br>

            </div>


            <% } else {  %>

              <div id='switcher-selector' class='pure-menu pure-menu-open pure-menu-horizontal' style="background: none;">
                  <ul id="topmenuitems">

                        <li class="pure-menu-selected-top">
                            <a href="javascript:">find</a>
                        </li>
                      <li>
                          <a href="edit">edit</a>
                      </li>
                      <li>
                          <a href="/import">import</a>
                      </li>

                  </ul>

                  <br>&nbsp;<br>

              </div>

            <% }  %>


                  <a href="javascript:" class="tooltip" title="hide this pane and all text" id="graph-link">
                      <span></span>
                  </a>
                  <a href="javascript:" class="tooltip" title="minimize this pane" id="windowdown-link">
                      <span></span>
                  </a>
                  <% if (!perceivername) { %>
                    <a href="/import" id="import-link" class="tooltip" title="import from external sources">
                        <!-- Import icon -->
                        <span></span>
                    </a>
                  <a href="javascript:" id="collaborate-link">
                      <!-- Collaborate icon -->
                      <span></span>
                  </a>
                  <% } %>

                  <% if (contextpublic && context && !perceivername) { %>
                  <a href="javascript:" id="privacy-link" class="is-public">
                      <!-- Share icon -->
                      <span></span>
                  </a>
                  <% } else if (!perceivername && context) { %>
                  <a href="javascript:" id="privacy-link">
                      <!-- Share icon -->
                      <span></span>
                  </a>
                  <% } %>

                  <% if ((context) && (!perceivername)) { %>
                  <form action='/post' name='deletecontext' id="deletecontext" method='post' class='pure-form' onsubmit="return confirm('Deleting the context will delete all the statements inside. Are you sure?');">

                      <input type="hidden" name="context" value="<%= context %>">
                      <input type="hidden" id="selectedContexts" name="selectedContexts" value="">
                      <input type="hidden" name="statementid" value="">
                      &nbsp;<br>
                      <input type='submit' id="deletecontextbutton" name="delete" value="delete context">

                  </form>
                  <% } %>






                  <!-- the panel to show content -->

            <div id="switcher-panel"></div>

            <!-- form to add, later do import here -->
            <% if (!perceivername) { %>
            <div id="adds-content" class="switcher-content set1 show">
            <% } else { %>
            <div id="adds-content" class="switcher-content set1">
            <% } %>
                <form action='/post' name='submitform' id="submitform" method='post' class='pure-form'>

                        <textarea columns="40" rows="4" name='entry[body]' id="statement" placeholder='type in some words or #hashtags to see how they connect'><% if (url) { %><%= urltitle %> <%= url %><% } %></textarea>
                        <div id="addToContextsLabel">in context:</div>
                        <ul id="addToContexts"></ul>
                        <input type="hidden" id="addedContexts" name="addedContexts">
                        <input type="hidden" id="context" name="context" value="<%= context %>">
                        <input type="hidden" id="selectedContexts" name="selectedContexts" value="">
                        <input type="hidden" id="statementid" name="statementid" value="">
                        <input type="hidden" name="timestamp" value="">
                        &nbsp;<br>
                        <input type='submit' id="submitbutton" name="btnSubmit" value="save" class="pure-button pure-button-primary">

                </form>

            </div>



            <!-- form to find -->
            <% if (perceivername) { %>
                <div id="finds-content" class="switcher-content set1 show">
            <% } else { %>
                <div id="finds-content" class="switcher-content set1">
            <% } %>
                <form class="pure-form" id="searchform">
                    <input type="text" id="search" size="14" maxlength="20" class="pure-input" placeholder="search...">
                    &nbsp;&nbsp;
                    <input type='submit' name="submit" value=">" class="pure-button pure-button-primary">
             </form>
            </div>
          </div>
        </div>

        <div id="graph-container"></div>

        <div id="messages">
        <% if (!perceivername) { %>
          <a href="javascript:" id="addnode" class="tooltip editorpane" title="add a node in the graph"></a>
        <% } %>
          <a href="javascript:" id="searchnode" class="tooltip" title="find a node in the graph"></a>
          <form action="" method="" class="pure-form" id="addnodeform"><input type="text" id="addnodeinput" size="10" placeholder="#node_name" class="pure-input"></form>
          <div id="pinnedlist"><a href="javascript:" id="undo" class="tooltip" title="remove selected nodes and reset graph" ></a><a href="javascript:" id="deletenodes" class="tooltip" title="remove selected nodes from the graph"></a><div id="pinnednodeslist"></div><div id="stopnodeslist"></div><a href="javascript:" id="stopsave" class="tooltip" title="save to permanent stopwords"></a></div></div>

                <a href="javascript:" id="chat-link" class="tooltip" title="show / hide the text">
                    <!-- Chat icon -->
                    <span></span>
                </a>
        <div id="controls">
                <div id="graph-reload">
                <a href="javascript:" class="tooltip" title="choose a few nodes from the graph and click this button to find out more"  id="go_next"></a><br><a href="javascript:location.reload();" class="tooltip" title="reload the graph" id="reloadbutton"></a><br><a href="javascript:" class="tooltip" title="improve layout" id="improve-layout"></a><br><a href="javascript:" class="tooltip" title="show tutorial" id="walkthrough"></a>

        </div>

        <div id="graph-tools">
                <a href="javascript:" class="tooltip" title="zoom in" id="zoom-in"></a><br><a href="javascript:" class="tooltip" title="zoom out" id="zoom-out"></a>
         </div>
         <div id="analytics"></div>

            <% if (!perceivername) { %>
                <a href="javascript:" id="microphone-link" class="tooltip editorpane" title="voice to text on/off">
                    <!-- Microphone icon -->
                    <span></span>
                </a>
                <a href="javascript:" id="addcontext-link" class="tooltip editorpane" title="compare to context">
                    <!-- Addcontext icon -->
                    <span></span>
                </a>
            <% } %>
            <a href="javascript:" class="tooltip editorpane" title="graph analytics" id="analyticsbutton"><div id="analyticscaption"></div></a>
      </div>

    </div>




</div>

<script src="/javascripts/sigma/sigma.min.js"></script>
<script src="/javascripts/sigma/plugins/sigma.parsers.json.min.js"></script>
<script src="/javascripts/sigma/plugins/sigma.layout.forceAtlas2.min.js"></script>
<script src="/javascripts/sigma/plugins/sigma.plugins.animate.min.js"></script>
<script src="/javascripts/sigma/plugins/sigma.plugins.dragNodes.min.js"></script>
<script src="/javascripts/sigma/plugins/jLouvain.js"></script>
<script src="/javascripts/sigma/plugins/distinct-colors.min.js"></script>
<script src="/javascripts/jquery-ui.min.js"></script>
<script src="/javascripts/string.min.js"></script>
<script src="/javascripts/underscore-min.js"></script>
<script src="/javascripts/jquery.textcomplete.js"></script>
<script src='/javascripts/jquery.autosize.js'></script>
<script src="/javascripts/ui.js"></script>
<script src="/javascripts/jquery.mobile-events.min.js"></script>
<script src="/javascripts/jquery.highlight-4.js"></script>
<script src="/javascripts/bundle-stemmer.js"></script>
<script src="/javascripts/jquery.taghandler.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script src="/javascripts/moment.min.js"></script>
<script type="text/javascript" src="/javascripts/jquery.tooltipster.min.js"></script>
<script src="/javascripts/cytoscape.min.js"></script>

             <script>
;(function(){

    var urlPath = location.pathname;

    // Initialize Socket.IO
    var socket = io('https://infranodus.com',{ transports: ['websocket'] });


    // Get URL variables in the form of an array

    function getUrlVars()
    {
        var vars = [], hash;
        var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
        for(var i = 0; i < hashes.length; i++)
        {
            hash = hashes[i].split('=');
            vars.push(hash[0]);
            vars[hash[0]] = hash[1];
        }
        return vars;
    }



    // First we query URL parameters

    /* {

     Which queries to add to search keywords from the graph:
     "go_next_add": "keyword",
     Which website to refer people to with the keywords (include search string with URL)
     "go_next_url" : "http://soundcloud.com/search?q="
     }

     */

    var forwardTo = 'https://www.google.com/search?q=';

    var go_next_url = getUrlVars()["go_next_url"];

    var go_next_site = getUrlVars()["go_next_site"];

    var go_next_add = getUrlVars()["go_next_add"];

    var go_next_override = getUrlVars()["go_next_override"];

    var link_hashtags = getUrlVars()["link_hashtags"];

    var convert_hashtags = getUrlVars()["convert_hashtags"];

    var hide_always = getUrlVars()["hide_always"];

    var hide_edit = getUrlVars()["hide_edit"];

    var show_text = getUrlVars()["show_text"];

    var show_analytics = getUrlVars()["analytics"];

    var hide_when_small = getUrlVars()["hide_when_small"];

    var language = getUrlVars()["language"];

    var mute = getUrlVars()["mute"];

    var speech = getUrlVars()["speech"];

    var walkthrough = getUrlVars()["walkthrough"];

    var newcontextname = getUrlVars()["newcontextname"];

    var graphPalette = getUrlVars()["palette"];

    var customization = ' ';

    var background = getUrlVars()["background"];

    var interpret = getUrlVars()["interpret"];

    var missing = getUrlVars()["missing"];

    var add_statement = getUrlVars()["statement"];

    var selected_keywords = getUrlVars()["keywords"];

    var voice_continues = getUrlVars()["voice_continues"];

    <% if (locals.user && locals.user.voice_continues != undefined && locals.user.voice_continues != '00') { %>
        voice_continues = '<%=locals.user.voice_continues%>';
    <% } %>

    var walkthroughtype = 'default';

    <% if (perceivername) { %>
    walkthroughtype = 'external';
    <% } %>

    if (go_next_url) {
        if ((go_next_url.substr(go_next_url.length - 1) == 's' || go_next_url.substr(go_next_url.length - 6) == 'search' || go_next_url.substr(go_next_url.length - 5) == 'query')) {
           go_next_url = go_next_url + '=';
        }
        forwardTo = go_next_url;
    }
    else if (go_next_site == 'soundcloud') {
        forwardTo = 'https://soundcloud.com/search?q=';
    }
    else if (go_next_site == 'youtube') {
        forwardTo = 'https://www.youtube.com/results?search_query=';
    }
    else if (go_next_site == 'wikipedia') {
        forwardTo = 'https://wikipedia.org/wiki/Special:Search?search=';
    }
    else if (go_next_site == 'amazon') {
        forwardTo = 'http://www.amazon.com/s/field-keywords=';
    }
    else if (go_next_site == 'twitter') {
        forwardTo = 'http://twitter.com/search?q=';
    }

    // For collaboration - Socket.IO chat
    var collaborate_invite = getUrlVars()["collaborate"];



// MAIN SETTINGS START

// Create node ID - Name index for filtering
var nodeIDs = {};

// What are the concepts displayed - the opposite of above
var nodeNames = [];

// Let's record all the unique edges we've got
var edgesList = [];

// Initial graph model saved
var nodesDB = [];
var edgesDB = [];

// Create context-node index for filtering
var contextNodeID = [];

// Create statement-node index for filtering
var nodesOfStatement = [];

// What are the concepts present in the graph?
var contextNames = [];

// What are the concepts present in the graph?
var statementsOfContext = [];

var current_context_field = [];


var community_of_node = [];

var jsonpath = '';

var addcontext = '';

var maxnodes = '';

<% if (maxnodes) { %>
  maxnodes = <%= maxnodes %>;
<% } %>


// Path to the JSON graph file (specific context or a general one)
    <% if (addcontext) { %>
        jsonpath = '/api/user/nodes/<%= context %>?addcontext=<%= addcontext %>';
        addcontext = "<%= addcontext %>";

    <% } else if (showcontexts) { %>
        jsonpath = '/api/user/nodes/<%= context %>?showcontexts=<%= showcontexts %>';
        addcontext = "";

        <% } else if (maxnodes) { %>
            jsonpath = '/api/user/nodes/<%= context %>?maxnodes=<%= maxnodes %>';
            addcontext = "";

    <% } else { %>
        jsonpath = '/api/user/nodes/<%= context %>';
        addcontext = "";
    <% }  %>


// Is the user going to look at somebody else's graph?

    <% if (perceivername) { %>
        <% if (showcontexts && maxnodes) { %>
            jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?showcontexts=<%= showcontexts %>&maxnodes=<%= maxnodes %>';
        <% } else if (showcontexts) { %>
            jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?showcontexts=<%= showcontexts %>';
        <% } else if (maxnodes) { %>
            jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?maxnodes=<%= maxnodes %>';
        <% } else  { %>
            jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>';
    <% } %>
    <% } %>


// Get current context
var path = window.location.pathname;
var current_context = '<%= context %>';
var current_user = path.replace(/^\/([^\/]*).*$/, '$1');
var hostsite = window.location.host;


// These are the nodes clicked in the graph
var pinnedNodes = [];
var splicedNodes = [];
var notfoundNodes = [];
var deletedNodes = [];

var selectedNodes = [];

// These are for Summary / Insight functionality

var most_inf_nodes = [];

var most_inf_comm_nodes = {};

var polysingularity_score = 0;

// Whats the clicked nodes in the graph
var clickedNodes = [];

// Inactivity timeout
var inactiveTimeout = null;

// This variable shows if there was a meaningful interaction with the graph yet
var graphInteraction = null;

// Loaded with graph only?
var graphOnly = null;


// Who posted the message?
var selfPosted = null;


// Socket.IO chat collaborate

// This matrix relates each URL path to each unique chat that can happen within that room

var collaborate_matrix = {};

var collaborate_room = urlPath + '/';

var collaborate_id = '';

var collaborate_content = '';

var collaborate_message = '';

var collaborate_html = '';

var collaborate_storage = JSON.parse(localStorage.getItem("collaborate"));

var sigma_dragged = 0;

// default label threshold
var in_label_threshold = 8;

// default most influential nodes are displayed according to Betwenness Centrality (bc) or Degree (degree)
var most_influential = 'bc';



var midi = '';

// TODO for desktop browses that support webwork (not iphone): webworker: true, slowdown: 300
var forceatlas_options = {worker: false, startingIterations: 100, scalingRatio: 0.1, slowDown: 100, strongGravityMode: true};

<% if (locals.user) { %>
var inlanguage = '<%= user.inlanguage %>';

<% if (locals.user.label_threshold) { %>
in_label_threshold = '<%= user.label_threshold %>';
<% } %>

<% if (locals.user.midi) { %>
midi = '<%= user.midi %>';
<% } %>

<% if (locals.user.topnodes) { %>
most_influential = '<%= user.topnodes %>';
<% } %>

if (getUrlVars()["most_influential"] == 'bc' || getUrlVars()["most_influential"] == 'bc2' || getUrlVars()["most_influential"] == 'degree') {
  most_influential = getUrlVars()["most_influential"];
}

if (!graphPalette) {
 graphPalette = '<%= user.palette %>';
}

<% if (locals.user.customization) { %>
 customization = '<%= user.customization %>';
<% } %>

if (!background) {
 background = '<%= user.background %>';
}





<% } %>

var deselected_nodes_color = '#ddd';

if (background == 'dark') {
  $('#graph-container').addClass('graph-dark');
  $('#analyticsbutton').addClass('analyticsbutton-dark');
  $('.entry').addClass('entry-dark');
  $('.entry-text').addClass('entry-text-dark');
  $('#analytics').addClass('analytics-dark');
  $('#entryform').addClass('entryform-dark');
  $('#addnodeinput').css({'backgroundColor': 'rgba(250, 250, 250, 0.2)', 'border': 'none', 'box-shadow': 'none', 'color': '#aaaab5'});
  $('#statement').css({'backgroundColor': 'rgba(250, 250, 250, 0.2)', 'border': 'none', 'box-shadow': 'none', 'color': '#aaaab5'});
  $('body').css('color', '#aaaab5');
  // $('li.pure-menu-selected-top a').css('backgroundColor', '#888888');
  $('.menu-link').css('background', 'rgba(250, 250, 250, 0.4)');
  $('#graph-link').addClass('graph-link-dark');
  $('#chat-link').addClass('chat-dark');
  $('#addnode').addClass('addnode-dark');
  $('#go_next').addClass('go_next-dark');
  $('#reloadbutton').addClass('reloadbutton-dark');
  $('#improve-layout').addClass('improve-layout-dark');
  $('#walkthrough').addClass('walkthrough-dark');
  $('#zoom-in').addClass('zoom-in-dark');
  $('#zoom-out').addClass('zoom-out-dark');
  $('#microphone-link').css({'background-image': "url('/images/microphone-white.png')", "opacity": "0.6"});
  $('#addcontext-link').css({'background-image': "url('/images/compare-white.png')", "opacity": "0.6"});
  $('#deletecontextbutton').addClass('deletecontextbutton-dark');
  $('#collaborate-link').addClass('collaborate-link-dark');
  $('#import-link').addClass('import-link-dark');
  $('#windowdown-link').addClass('windowdown-link-dark');
  deselected_nodes_color = '#444';
}

$('#analyticscaption').html(customization);

<% if (locals.user) { %>
<% if (locals.user.midi != undefined && locals.user.midi != 'off') { %>

var output;
var input;

function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

WebMidi.enable(function (err) {

  if (err) {
    console.log("WebMidi could not be enabled.", err);
  } else {


    console.log("WebMidi enabled!");
    console.log(WebMidi.inputs);
    console.log(WebMidi.outputs);
    console.log(WebMidi.time);

    output = WebMidi.outputs[0];
    console.log('midi substr ' + midi.substr(4,2));

    if (midi.substr(4,2) != '00') {
      output = WebMidi.outputs[parseInt(midi.substr(4,2))];
    }

    if (output) {
      console.log('MIDI device connected');
    }
    else {
      console.log('MIDI out device not connected');
    }

    input = WebMidi.inputs[0];

    if (input) {

      // Listen for a 'note on' message on all channels
      input.addListener('noteon', "all",
        function (e) {
          console.log("Received 'noteon' message (" + e.note.name + e.note.octave + ").");
          console.log(e);

          if (midi.substr(14,2) != '' && midi.substr(14,2) != undefined && midi.substr(14,2) != 'no') {
            $('#statement').val($('#statement').val() + '#' + e.note.name.replace(/#/g,'') + e.note.number + ' ');
          }

        }
      );
    }
    else {
      console.log('MIDI input device not connected');
    }

  }



});

<% } %>
<% } %>


// If the user opened a URL with collaborate=xxxxxx then they join the room that's the "url_path/xxxxxx"
if (collaborate_invite) {
    collaborate_id = collaborate_invite;
}
// Otherwise they join a room which is "url_path/randomnumber"
else {
    collaborate_id = Math.round((Math.random() * 1000000));
}

collaborate_matrix[collaborate_room] = collaborate_room + collaborate_id;

console.log('room id');
console.log(collaborate_matrix[collaborate_room]);

if (!collaborate_invite) {
    if (collaborate_storage) {

        if (collaborate_storage[collaborate_room]) {
            if (collaborate_storage[collaborate_room].length > 0) {
                collaborate_matrix[collaborate_room] = collaborate_storage[collaborate_room];
                collaborate_id = collaborate_matrix[collaborate_room].split("/").pop();
            }
        }
    }

    // Now in case the original user reloads the page by error, they'll get the new collaborate ID, so we avoid that by storing their data
    localStorage.setItem("collaborate", JSON.stringify(collaborate_matrix));
}


    // On connection to server get the id of the current chat "room", which is actually the folder/URL of the current user

    socket.on('connect', function(){
        console.log('connected');
        socket.emit('login', {user: current_user, context: current_context, id: collaborate_matrix[collaborate_room]});
    });


    socket.on('startChat', function(data){
        console.log('chat started');
        if(data.boolean && data.id == collaborate_matrix[collaborate_room]) {
            console.log('in chat room ' + data.id);
            var collab_content = $('#collaborate-link').tooltipster('content');
            $('#collaborate-link').tooltipster('content', 'Collaboration is ON');
            $('#collaborate-link').addClass('is-collab');
            $('#collaborate-link').tooltipster('show');
            setTimeout(function() {
                $('#collaborate-link').tooltipster('hide');
                setTimeout(function() {
                    $('#collaborate-link').tooltipster('content', collab_content);
                }, 1000);

            }, 2000);
        }
    });

    socket.on('leave', function(msg){
        console.log('partner left');
        console.log(msg.people);
        if (msg.people < 2) {
          $('#collaborate-link').removeClass('is-collab');
          var collab_content = $('#collaborate-link').tooltipster('content');
          $('#collaborate-link').tooltipster('content', 'Collaboration is OFF');
          $('#collaborate-link').tooltipster('show');
          setTimeout(function() {
              $('#collaborate-link').tooltipster('hide');
              setTimeout(function() {
                  $('#collaborate-link').tooltipster('content', collab_content);
              }, 1000);
          }, 2000);
        }
    });

    socket.on('tooMany', function(data){

        console.log('one too many');
        alert('There are already 2 users working on this context and this is our max so far. If you think it is a mistake, please, check if any of your extra browser tabs are opened.');
        window.location.href = 'http://' + hostsite + '/' + 'home' + '/edit';

    });



// The button to hide / show statements

$("#graph-link").click(function(e) {
    e.preventDefault();

    // The user clicked on the graph icon, so we reset his graph interaction activity for timeout later
    graphInteraction = null;
    clearTimeout(inactiveTimeout);

    toggle_statements();
});

    $("#windowdown-link").click(function(e) {
        e.preventDefault();
        // if ((localStorage.getItem('folded') == 1)) {
        //     $('#entryform').css({top: 'auto', 'margin-top': '0px'});
        //     $('#entries').css({height:  $(window).height() - $('#entryform').height() - 75});
        //     $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);
        //     $('#deletecontext').show();
        //     $('#privacy-link').show();
        //     $('#collaborate-link').show();
        //     $('#import-link').show();
        //     localStorage.setItem('folded', 0);
        // }
        // else {
        //     $('#entryform').css({top:  $(window).height(), 'margin-top': '-50px'});
        //     $('#entries').css({height:  $(window).height() - 80});
        //     $('#deletecontext').hide();
        //     $('#privacy-link').hide();
        //     $('#collaborate-link').hide();
        //     $('#import-link').hide();
        //     localStorage.setItem('folded', 1);
        // }




        $("#entries").fadeToggle();

    });





    document.addEventListener("DOMContentLoaded", function(event) {


        submitFormProcess();


    });



function submitFormProcess() {

    document.querySelector('#submitform').addEventListener('submit', function(e) {

        e.preventDefault();

        $('#statement').addClass('loading');

        $('#submitbutton').attr('disabled', 'disabled');

        // We will set a user for posting. If the posting user does not equal the user who's watching the graph, we force-add the statement into theirs (provided they collaborate)
        var postedby = '';

        <% if (receivername) { %>
           postedby = '<%= receivername %>';
        <% } %>
        // TODO make it possible that those statements get submitted in both graphs

        // is urlvars mute off? then post as usual
        if (!mute) {
        $.post('/post', $("#submitform").serialize())
                .done(function(res) {
                    //3. Receive the server response, no need to emit an event
                    if (res.entryuid) {
                        //4. Show the updated text
                        selfPosted = '1';
                        $("#statement").val('');
                        $('#statement').removeClass('loading');
                        $('#submitbutton').removeAttr('disabled');
                        // TODO make a better fix for temporary graph
                        if (res.entryuid == 'multiple') {
                            socket.emit('chat message', {postedby: postedby, entryuid: 'multiplesocket', entrytext: res.entrycontent, graph: res.graph});
                            if (res.successmsg) {
                              $("#warnings").append('<p class="warning">Please, reload the page after a few seconds to see the graph.</p>');
                              $("#warnings").slideDown('slow');
                            }
                            setTimeout(function() {
                                location.reload();
                            },3000);
                        }
                        else {

                            socket.emit('chat message', {postedby: postedby, entryuid: JSON.parse(res.entryuid).data, entrytext: res.entrytext, graph: res.graph});
                        }

                    }
                    else if (res.errormsg) {
                        $('#statement').removeClass('loading');
                        $('#submitbutton').removeAttr('disabled');
                        alert(res.errormsg);
                    }
                    else {
                        alert('Something went wrong, please, try again...');
                    }
                })
                .fail(function(res) {
                    alert("Server Error: " + res.status + " " + res.statusText);
                });

        }
        // otherwise - make a dummy post - it appears in the list but doesn't get submitted into the graph
        else {
            selfPosted = '1';
            $('#statement').removeClass('loading');
            $('#submitbutton').removeAttr('disabled');
            $("#statement").val('');
            socket.emit('chat message', {mute: 1, postedby: postedby, entryuid: '', entrytext: $('#statement').val(), graph: ''});
        }

        return false;
    });

    $('#statement').keypress(function(e){

        // Submit the form on enter

        if(e.which == 13 && !e.shiftKey) {
            e.preventDefault();
            $('#submitbutton').trigger('click');
        }

    });

}

// Hide / Show Statements DIV

function toggle_statements() {

    /*$('#graph-link').toggleClass('graph-chat');
    $('#entries').toggleClass("hide-entries");
    $('#statements').toggleClass("hide-statements");

    if ($('#graph-link').hasClass('graph-chat')) {
        //$('#switcher-panel').toggleClass("hide-menu");
        $('#finds').trigger('click');
        $('#switcher-selector').toggleClass("hide-menu");
    }
    else {
        // $('#switcher-panel').toggleClass("hide-menu");
        $('#switcher-selector').toggleClass("hide-menu");
        if (pinnedNodes.length == 0) {
            $('#adds').trigger('click');
        }
    }*/

    $("#statements").fadeToggle();
    if (!$("#chat-link").hasClass('chat-highlight')) {
        localStorage.setItem('graph', 1);
    }
    else {
        localStorage.setItem('graph', 0);
    }
    $("#chat-link").toggleClass('chat-highlight');

    if (!localStorage.getItem('analytics')) {
    $('#analytics').toggle('slide', function(){
      if ($('#analytics').is(":visible")) {
            $('#analyticsbutton').addClass('analytics-on');
            $('#analyticscaption').hide();
            //localStorage.setItem('analytics', 1);
      }
      else {
            $('#analyticsbutton').removeClass('analytics-on');
            $('#analyticscaption').show();
            //localStorage.setItem('analytics', 0);
          }
    });
    }



}

function showStatements () {
        var isHidden_ = $("#statements").is(":hidden");
        if (isHidden_) {
            $('#statements').fadeIn();
            $("#chat-link").toggleClass('chat-highlight');
        }
}

function showEntries () {
        var isHidden_ = $("#entries").is(":hidden");
        if (isHidden_) {
            $('#entries').fadeIn();
        }
}


// Add Cytoscape Library

var cy = cytoscape({
    container: undefined,
    headless: true
});

// Cytoscape object

var elesnodes = [];

var eles;

var topbc_nodes = [];

var top_components = [];


// Add a method to the graph model that returns an
// object with every neighbors of a node inside:

sigma.classes.graph.addMethod('neighbors', function(nodeId) {
    var k,
            neighbors = {},
            index = this.allNeighborsIndex[nodeId] || {};

    for (k in index)
        neighbors[k] = this.nodesIndex[k];

    return neighbors;
});

// Initialize JSON parser for SIGMA visualization

var color_addcontext = '#666666'; // #cccccc

var default_label_color = '#000000';

if (background == 'dark') {
  default_label_color = '#ffffff';
}



sigma.parsers.json(
        jsonpath,
        {
            container: 'graph-container',
            renderer: {
                container: document.getElementById('graph-container'),
                type: 'canvas'
            },
            settings: {
                minNodeSize: 5,
                maxNodeSize: 16,
                minEdgeSize: 0.5,
                maxEdgeSize: 2,
                labelThreshold: in_label_threshold,
                defaultLabelColor: default_label_color
            }
        },
        function(sigma) {
            var i,
                    timeout = 4000,
                    nodes = sigma.graph.nodes(),
                    color_context = '#666',
                    color_addcontext = '#cccccc',
                    len = nodes.length;




            // This is a fix for JSON
            // Sigma requires that nodes have X, Y, Size and Color properties which our JSON doesn't have. So we add them.
            // We also make the initial graph layout circular, so that ForceAtlas always looks the same

            var maxnodesize = 0;

            for (i = 0; i < len; i++) {
                var nodesize = 0;
                var angle = Math.PI * 2 * i / len;
                nodes[i].x = Math.cos(angle);
                nodes[i].y = Math.sin(angle);
                nodes[i].size = sigma.graph.degree(nodes[i].id);
                nodesize = nodes[i].size;
                if (maxnodesize < nodesize) maxnodesize = nodesize;
                nodes[i].color = color_context;

                // Add to Cytoscape
                elesnodes.push({
                    group: "nodes",
                    data: { id: nodes[i].id, name: nodes[i].label}
                });

            }

            // We first need to save the original colors and LABELS of our
            // nodes and edges, like this:

            sigma.graph.edges().forEach(function(e) {

                var unique_edge_id = '';

                // Let's see if the edge source in alphabetical order is further than its target and change places

                if (e.source > e.target) {
                    unique_edge_id = e.target + '-' + e.source;
                }
                else {
                    unique_edge_id = e.source + '-' + e.target;
                }


                // Let's make a unique list of edges to count how many there are of the same kind

                if (edgesList[unique_edge_id]) {
                    ++edgesList[unique_edge_id];

                    // TODO this is a bit of a workaround - in the future could be better to distribute the weight evenly
                    e.size = e.weight + edgesList[unique_edge_id];
                }
                else {
                    edgesList[unique_edge_id] = 1;
                    e.size = e.weight;
                }


                e.originalColor = e.color;

                // Make an index of nodes to context
                if (contextNodeID[e.edge_context]) {
                    if (contextNodeID[e.edge_context].indexOf(e.source) < 0)
                        contextNodeID[e.edge_context].push(e.source);
                    if (contextNodeID[e.edge_context].indexOf(e.target) < 0)
                        contextNodeID[e.edge_context].push(e.target);
                }
                else {
                    contextNodeID[e.edge_context] = [];
                    contextNodeID[e.edge_context].push(e.source);
                    contextNodeID[e.edge_context].push(e.target);
                }

                // Make an index of nodes to statement
                if (nodesOfStatement[e.statement_id]) {
                    if (nodesOfStatement[e.statement_id].indexOf(e.source) < 0)
                        nodesOfStatement[e.statement_id].push(e.source);
                    if (nodesOfStatement[e.statement_id].indexOf(e.target) < 0)
                        nodesOfStatement[e.statement_id].push(e.target);
                }
                else {
                    nodesOfStatement[e.statement_id] = [];
                    nodesOfStatement[e.statement_id].push(e.source);
                    nodesOfStatement[e.statement_id].push(e.target);
                }

                if (statementsOfContext[e.edge_context]) {
                    if (statementsOfContext[e.edge_context].indexOf(e.statement_id) < 0)
                        statementsOfContext[e.edge_context].push(e.statement_id);
                }
                else {
                    statementsOfContext[e.edge_context] = [];
                    statementsOfContext[e.edge_context].push(e.statement_id);
                }

                // Add to Cytoscape
                elesnodes.push({
                    group: "edges",
                    data: { id: unique_edge_id, source: e.source, target: e.target }
                });

                // Add to EDGES db
                edgesDB.push(e);

            });




            sigma.graph.nodes().forEach(function(n) {

                // Save node's default color, for hide and show later
                n.originalColor = n.color;
                n.originalLabel = n.label;

                // Creating an index of node labels to IDs for filtering
                var key = n.label;
                nodeIDs[key] = n.id;

            });


           //sigma.refresh();





            // for (var j = 0; j < cy.nodes().length; j++) {
            //    console.log(cy.edges()[j].data());
            // }

            //  console.log(eles.getElementById('d5167020-d3ac-11e3-a954-ab35be27f3fc'));


            // Make a list of all the node labels displayed in the graph (for Autofill)

            nodeNames = _.keys(nodeIDs);



            // Get the context names - all the contexts that exist in the graph we just loaded
            // This IF statement is for the case when the contextlist parameter is not passed on

            // NOTE this function can be activated if you want to get the list of contexts from the visible graph only
            // contextNames = _.keys(contextNodeID);

            // populateContextMenu(contextNames);

            // Now we get the context IDs from the graph - a little bit of a workaround
            var suspects = [];
            var nonsuspects = [];

            sigma.graph.edges().forEach(function(e) {

                // If an edge has a context prefix, one of its nodes is a context, but we don't know which yet

                if (e.id.substr(0,7) == 'context') {
                        if (suspects.indexOf(e.source) < 0) {
                            suspects.push(e.source);
                        }

                        if (suspects.indexOf(e.target) < 0) {
                            suspects.push(e.target);
                        }

                }

                // If an edge doesn't have prefix context, for sure it has only nodes
                else {
                        if (nonsuspects.indexOf(e.source) < 0) {
                            nonsuspects.push(e.source);
                        }

                        if (nonsuspects.indexOf(e.target) < 0) {
                            nonsuspects.push(e.target);
                        }
                }



            });

            // Find the difference between two arrays above, so we get contexts only
            var contextids = _.difference(suspects, nonsuspects);


            // Now show those nodes that are contexts bigger and with a special label

            for (i = 0; i < len; i++) {

                if (contextids.indexOf(nodes[i].id) > -1) {
                    nodes[i].size = maxnodesize;
                    nodes[i].originalLabel = 'context: ' + nodes[i].originalLabel;
                    nodes[i].label = 'context: ' + nodes[i].label;
                }


            }




            // Initialize autofill for hashtags and contexts
            autofill(nodeNames,contextNames);


            if (document.getElementById('context').value) {
                current_context_field = [document.getElementById('context').value];
                $("#addedContexts").val(document.getElementById('context').value);
            }

            // if not, we're making the 'private' context default
            else {
                var lastcontexts = [];
                var laststatement = $(".entry:last").attr('data-uid');
                console.log(laststatement);
                for (var key in statementsOfContext) {
                    var reiteratestatements = statementsOfContext[key];
                    for (var i = 0; i< reiteratestatements.length; i++) {
                        if (laststatement == reiteratestatements[i]) {
                            lastcontexts.push(key);
                            console.log(key);
                        }
                    }

                }
                if (lastcontexts[0] == 'help' || !lastcontexts[0]) {
                    current_context_field = ['private'];
                    $("#addedContexts").val('private');
                }

                else {
                    current_context_field = lastcontexts;
                    $("#addedContexts").val(current_context_field.join());
                }
            }

            // let's now populate contextHandlers

            $("#addToContexts").tagHandler({
                assignedTags: current_context_field,
                availableTags: contextNames,
                autocomplete: true,
                afterAdd: function(tag) {
                    current_context_field.push(tag);
                    $("#addedContexts").val(current_context_field.join());
                    console.log('contexts in hidden field: ' + current_context_field.join());
                },
                afterDelete: function(tag) {
                    console.log('initiated delete from sigma');
                    for (var i=current_context_field.length-1; i>=0; i--) {
                        if (current_context_field[i] === tag) {
                            current_context_field.splice(i, 1);
                        }
                    }
                    $("#addedContexts").val(current_context_field.join());
                    console.log('contexts in hidden field: ' + current_context_field.join());
                }
            });

            if (background == 'dark') { $('#tagInputBox').css({'backgroundColor': 'rgba(250, 250, 250, 0.2)', 'border': 'none', 'box-shadow': 'none', 'color': '#aaaab5'}); }
            // Do ForceAtlasLayout

            if (sigma.isForceAtlas2Running()) {
                sigma.stopForceAtlas2();
                sigma.killForceAtlas2();
            }
            else {
              sigma.startForceAtlas2(forceatlas_options);
            }


            // Don't run it forever not to overheat :)

            setTimeout(function() {
                sigma.stopForceAtlas2();
                sigma.killForceAtlas2();

            },timeout);


            // Drag nodes

            dragNodes();

            // Betweenness Centrality Calculation using Cytoscape
            eles = cy.add(elesnodes);


            //console.log(eles.nodes().length);

            betweennessCentrality(eles);

            // Community detect algorithm

            communityDetect();




            // TODO make it possible for collaboration also

            if (addcontext && interpret) {

              $('.entry').hide();

              for (var ite in statementsOfContext[current_context]) {

                $('.entry[data-uid="' + statementsOfContext[current_context][ite] + '"]').each(function() {
                  $(this).show();
                });

              }

              // $('.entry').each(function() {
              //   if ($(this).is(':hidden')) {
              //     $(this).remove();
              //   }
              // });



            }



            $('#analyticsbutton').click(function(){

                     $('#analytics').toggle('slide', function(){
                       if ($('#analytics').is(":visible")) {
                         localStorage.setItem('analytics', 1);
                         $('#analyticsbutton').addClass('analytics-on');
                         $('#analyticscaption').hide();

                       }
                       else {
                         localStorage.setItem('analytics', 0);
                         $('#analyticsbutton').removeClass('analytics-on')
                         $('#analyticscaption').show();
                       }
                     });



            });

            $('#analytics').on('swipedown',function(){$('#analyticsbutton').trigger('click');});

            // When a node is clicked, we check for each node
            // if it is a neighbor of the clicked one. If not,
            // we set its color as grey, and else, it takes its
            // original color.
            // We do the same for the edges, and we only keep
            // edges that have both extremities colored.

            sigma.bind('clickNode', function(e) {
              if (!sigma_dragged) {
                // A node was clicked, so we assume there was a meaningful graph interaction
                graphInteraction = 1;

                var nodeLabel = e.data.node.originalLabel;

                if (interpret) {
                  $('.entry').show();
                }


                if (nodeLabel.substr(0,9) == 'context: ') {
                    window.open('/' + current_user + '/' + nodeLabel.substr(9,nodeLabel.length) + '<% if (!perceivername) { %>/edit<% } %>',"_self");
                }
                else {

                    // Was the node clicked already? No? Add it to array of clicked nodes.
                    // Highlight the clicked node in the text.


                    if (splicedNodes.length > 1) {
                         pinnedNodes = [];
                         for (var p = 0; p < splicedNodes.length; p++ ){
                             pinnedNodes[p] = splicedNodes[p];
                         }
                    }
                    else if (splicedNodes.length == 1) {
                        pinnedNodes = [];
                        pinnedNodes[0] = splicedNodes[0];
                        splicedNodes = [];
                    }

                    if (pinnedNodes.indexOf(nodeLabel) < 0) {
                        pinnedNodes.push(nodeLabel);
                    }
                    else {
                        var pinnedIndex = pinnedNodes.indexOf(nodeLabel);
                        if (pinnedIndex > -1) {
                            pinnedNodes.splice(pinnedIndex,1);
                            $('.entry').fadeIn(400);
                        }

                    }

                    // console.log("node clicked, now will filter for nodes " + pinnedNodes);
                    socket.emit('node click', {pinnedNodes: pinnedNodes, splicedNodes: splicedNodes, nodeLabel: nodeLabel, pinnedIndex: pinnedIndex});


                    // Now show / hide statements that have the search field

                    filter_statements(pinnedNodes);




                    // If the window is wide enough to show the menu AND div with statements is not visible

                    var isHidden = $("#statements").is(":hidden");

                    // if (isHidden) {
                    //
                    //     var delayShow = 6000;
                    //
                    //     clearTimeout(inactiveTimeout);
                    //     inactiveTimeout = setTimeout(showStatements, delayShow);
                    //
                    //     $('#graph-container').unbind('mousemove orientationchange scroll swipe tap swipeleft swiperight scrolltop');
                    //     $('#graph-container').bind('mousemove orientationchange scroll swipe tap swipeleft swiperight scrolltop', function(){
                    //         if (graphInteraction) {
                    //             clearTimeout(inactiveTimeout);
                    //             inactiveTimeout = setTimeout(showStatements, delayShow);
                    //         }
                    //     });
                    //
                    //
                    // }

                }

              }
              sigma_dragged = 0;


            });


            // Show node's label when we're over it

            sigma.bind('overNode', function(e) {
                e.data.node.label = e.data.node.originalLabel;
                sigma.refresh();
            });



            // Hide node's label when we're out of it

            sigma.bind('outNode', function(e) {
                if (e.data.node.color != e.data.node.originalColor && pinnedNodes.indexOf(e.data.node.originalLabel) < 0) {
                    e.data.node.label = '';
                }
                sigma.refresh();
            });



            // Zoom Graph Control

            var c = sigma.camera;


            $("#zoom-in").on('click', function(e) {
                // Zoom in - single frame :
                c.goTo({
                    ratio: c.ratio / c.settings('zoomingRatio')
                });
            });

            $("#zoom-out").on('click', function(e) {
                // Zoom out - single frame :
                c.goTo({
                    ratio: c.ratio * c.settings('zoomingRatio')
                });
            });

            $("#improve-layout").on('click', function(e) {
                if (sigma.isForceAtlas2Running()) {
                    sigma.stopForceAtlas2();
                    sigma.killForceAtlas2();
                    $('#improve-layout').removeClass('layout-on');
                }
                else {
                  // sigma.configForceAtlas2({scalingRatio: 0.1});
                  sigma.startForceAtlas2(forceatlas_options);
                  $('#improve-layout').addClass('layout-on');

                }


            });


            // Forward from the graph function

            $("#go_next").on('click', function(e) {

                var searchQuery = pinnedNodes.join("+");



                if (go_next_add) {
                    searchQuery = searchQuery + '+' + go_next_add;
                }

                if (searchQuery.length > 0 || go_next_add) {

                    if (go_next_override) {
                        if (pinnedNodes.length > go_next_override) {
                            window.open('http://google.com/search?q=' + searchQuery,'_blank');
                        }
                       else {
                            window.open(forwardTo + searchQuery,'_blank');
                        }
                    } else {
                        window.open(forwardTo + searchQuery,'_blank');
                    }
                }
                else {
                    alert("Click this after you select a few nodes to find them on the web.");
                }



            });



            // Here we perform some live updates of the graph on receiving a Socket.IO message
            // We could also move this code and use sigma.instances(0).graph.nodes() to get sigma properties

            // TODO set up chatroom, make better design, think of graph sharing functionality

            socket.on('chat message', function(msg){

                var perceivedby = '';

                <% if (receivername) { %>
                   perceivedby = '<%= receivername %>';
                <% } %>

                var posted_by = msg.postedby;

                var added_entry =  "<div class='entry' style='display: none;' data-uid='" + msg.entryuid + "'><p class='entry-text'>" + msg.entrytext + "</p><p class='entry-date'>by " + posted_by + " at " + moment().format('hh:mm:ss') + "</p><div class='separator'>&nbsp;</div><div id='" + msg.entryuid + "' class='hidden'></div></div>";

                // if the message is not self-posted and also if the poster of the message is not the same as the guy logged in (in case there's two logins simultaneously)
                if (!selfPosted && perceivedby != posted_by) {
                    // add the alien class so the posted message looks like it's from elsewhere
                    added_entry =  "<div class='entry alien' style='display: none; margin-left: 50px' data-uid='" + msg.entryuid + "'><p class='entry-text gray'>" + msg.entrytext + "</p><p class='entry-date gray'>by " + posted_by + " at " + moment().format('hh:mm:ss') + "</p><div class='separator'>&nbsp;</div><div id='" + msg.entryuid + "' class='hidden'></div></div>";

                    if (msg.help) {
                        added_entry =  "<div class='entry alien' style='display: none; margin-left: 50px' data-uid='" + msg.entryuid + "'><p class='entry-text gray'>" + msg.entrytext + "</p><p class='entry-date gray'>help tip &nbsp;<em></em><a href='javascript:' class='disablehelp'>disable</a></em></p><div class='separator'>&nbsp;</div><div id='" + msg.entryuid + "' class='hidden'></div></div>";
                    }

                    // We will set a user for receiving. If the posting user does not equal the user who's watching the graph, we force-add the statement into theirs (provided they collaborate)
                    var receivedby = '';

                     <% if (perceivername) { %>
                        receivedby = '<%= perceivername %>';
                    <% } %>

                    // TODO make it possible that those statements get submitted in both graphs

                    // So the user who posted is not the same who's receiving? then submit the form. If the sender didnt have the mute option
                    if ((receivedby != msg.postedby) && !msg.mute) {


                        /*var temporary_statement = $('#statement').val();
                        $('#statement').val(msg.entrytext);
                        console.log($("#submitform").serialize());*/

                        var to_submit = $('#submitform').serializeArray();

                        for (key in to_submit) {
                            if (to_submit[key].name == 'entry[body]') {
                                to_submit[key].value = msg.entrytext;
                            }
                        }

                        $.post('/post', $.param(to_submit))
                                .done(function(res) {

                          /*          $('#statement').val(temporary_statement);*/

                                    //3. Receive the server response, no need to emit an event
                                    if (res.entryuid) {
                                        //4. Show the updated text

                                        if (res.entryuid == 'multiple') {
                                          if (res.successmsg) {
                                            $("#warnings").append('<p class="warning">Your collaborator submitted a long text. Please, reload the page to see the graph.</p>');
                                            $("#warnings").slideDown('slow');
                                          }
                                          setTimeout(function() {
                                              location.reload();
                                          },3000);
                                        }
                                    }
                                    else if (res.errormsg) {
                                        alert(res.errormsg);
                                    }
                                    else {
                                        alert('Something went wrong, please, try again...');
                                    }
                                })
                                .fail(function(res) {
                                    alert("Server Error: " + res.status + " " + res.statusText);
                                });

                    }



                }
                else {
                    selfPosted = null;
                }

                $(added_entry).appendTo($('#entries')).slideDown("fast");

                if (background == 'dark') {
                  $('.entry').addClass('entry-dark');
                  $('.entry-text').addClass('entry-text-dark');
                }

                $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);

                //$('#entries').append(added_entry).slideUp("fast");

                if ($(window).height() < 600) {
                    document.activeElement.blur();
                }


                    entryClick();
                    entryDoubleClick();

                    var addednodes = msg.graph.nodes;
                    var addededges = msg.graph.edges;

                    var nodes_added = [];
                    var edges_added = [];



                    for (var i = 0; i < addednodes.length; i++) {

                        if (nodeNames.indexOf(addednodes[i].label) == -1) {

                           // var angle = Math.PI * 2 * i / len;

                            sigma.graph.addNode({
                                id: (id = addednodes[i].id),
                                label: addednodes[i].label,
                                originalLabel: addednodes[i].label,
                                originalColor: color_context,
                                size: maxnodesize - 2,
                                x: Math.random(),
                                y: Math.random(),
                                color: color_context
                            });
                            nodeNames.push(addednodes[i].label);
                            nodes_added.push(addednodes[i]);


                        }


                    }

                    for (var j = 0; j < addededges.length; j++) {

                       if ((addededges[j].statement_id == msg.entryuid)) {


                         var unique_edge_id = '';

                         // Let's see if the edge source in alphabetical order is further than its target and change places

                         if (addededges[j].source > addededges[j].target) {
                             unique_edge_id = addededges[j].target + '-' + addededges[j].source;
                         }
                         else {
                             unique_edge_id = addededges[j].source + '-' + addededges[j].target;
                         }

                            sigma.graph.addEdge({
                                id: addededges[j].id,
                                source: addededges[j].source,
                                target: addededges[j].target,
                                weight: addededges[j].weight,
                                size: addededges[j].weight,
                                statement_id: addededges[j].statement_id,
                                edge_context: addededges[j].edge_context
                            });

                            edges_added.push(addededges[j]);


                        }

                    }

                    var collection = cy.elements();
                    cy.remove(collection);

                    elesnodes = [];

                    sigma.graph.nodes().forEach(function(n) {
                        if (n.id == 'dummy') {
                            sigma.graph.dropNode('dummy');
                        }
                        else {

                          // Add to Cytoscape
                          elesnodes.push({
                              group: "nodes",
                              data: { id: n.id, name: n.label}
                          });

                        }

                      //n.size = sigma.graph.degree(n.id);

                    });

                    // TODO this code duplicates from above - move into a function
                    sigma.graph.edges().forEach(function(e) {

                      var unique_edge_id = '';

                      // Let's see if the edge source in alphabetical order is further than its target and change places

                      if (e.source > e.target) {
                          unique_edge_id = e.target + '-' + e.source;
                      }
                      else {
                          unique_edge_id = e.source + '-' + e.target;
                      }


                        // Make and index of nodes to statement
                        if (nodesOfStatement[e.statement_id]) {
                            if (nodesOfStatement[e.statement_id].indexOf(e.source) < 0)
                                nodesOfStatement[e.statement_id].push(e.source);
                            if (nodesOfStatement[e.statement_id].indexOf(e.target) < 0)
                                nodesOfStatement[e.statement_id].push(e.target);
                        }
                        else {
                            nodesOfStatement[e.statement_id] = [];
                            nodesOfStatement[e.statement_id].push(e.source);
                            nodesOfStatement[e.statement_id].push(e.target);
                        }

                        if (statementsOfContext[e.edge_context]) {
                            if (statementsOfContext[e.edge_context].indexOf(e.statement_id) < 0)
                                statementsOfContext[e.edge_context].push(e.statement_id);
                        }
                        else {
                            statementsOfContext[e.edge_context] = [];
                            statementsOfContext[e.edge_context].push(e.statement_id);
                        }

                                        // Make an index of nodes to context
                                        if (contextNodeID[e.edge_context]) {
                                            if (contextNodeID[e.edge_context].indexOf(e.source) < 0)
                                                contextNodeID[e.edge_context].push(e.source);
                                            if (contextNodeID[e.edge_context].indexOf(e.target) < 0)
                                                contextNodeID[e.edge_context].push(e.target);
                                        }
                                        else {
                                            contextNodeID[e.edge_context] = [];
                                            contextNodeID[e.edge_context].push(e.source);
                                            contextNodeID[e.edge_context].push(e.target);
                                        }


                        // Add to Cytoscape
                        elesnodes.push({
                            group: "edges",
                            data: { id: unique_edge_id, source: e.source, target: e.target }
                        });


                    });


                    // Betweenness Centrality Calculation using Cytoscape
                    eless = cy.add(elesnodes);

                    // console.log(eles.nodes().length);

                    betweennessCentrality(eless);
                    communityDetect();

                    //sigma.refresh();

                    sigma.startForceAtlas2(forceatlas_options);

                    // MIDI activation

                    <% if (locals.user) { %>
                    <% if (locals.user.midi != undefined && locals.user.midi != 'off') { %>


                    console.log('using MIDI data ' + midi);
                    console.log('playing MIDI device:');
                    console.log(output);

                    var timecode = 0;

                    var note_node = midi.substr(10,2);
                    if (note_node.substr(1,1) == '0') {
                      note_node = note_node.substr(0,1) + '1';
                    }

                    var note_edge = midi.substr(12,2);
                    if (note_edge.substr(1,1) == '0') {
                      note_edge = note_edge.substr(0,1) + '1';
                    }



                    for (var m = 0; m < nodes_added.length; m++) {


                        setTimeout(function () {
                          output.playNote(note_node, parseInt(midi.substr(0,2)));
                          output.stopNote(note_node, parseInt(midi.substr(0,2)), {time: "+500"});
                          console.log('playing a node note ' + note_node + ' at ' + timecode + ' on channel ' + parseInt(midi.substr(0,2)));
                        }, timecode);
                        timecode = getRandomInt(0,parseInt(midi.substr(6,4)));
                    }

                    var timecodea = 0;

                    for (var ed = 0; ed < edges_added.length; ed++) {

                        setTimeout(function () {
                          output.playNote(note_edge, parseInt(midi.substr(2,2)));
                          output.stopNote(note_edge, parseInt(midi.substr(2,2)), {time: "+500"});
                          console.log('playing an edge note ' + note_edge + ' at ' + timecodea + ' on ' + parseInt(midi.substr(2,2)));
                        }, timecodea);
                          timecodea = getRandomInt(0,parseInt(midi.substr(6,4)));

                    }

                    <% } %>
                    <% } %>



                    // Don't run it forever not to overheat :)

                    setTimeout(function() {

                        sigma.stopForceAtlas2();
                        sigma.killForceAtlas2();

                    }, 3000);

                    //console.log(newnodes);
                    // console.log(msg.graph.edges);
                    // console.log(sigma.graph.edges());

                    // TODO right now it doubles


                    if (addcontext && interpret) {

                      $('.entry').hide();

                      for (var ite in statementsOfContext[current_context]) {

                        $('.entry[data-uid="' + statementsOfContext[current_context][ite] + '"]').each(function() {
                          $(this).show();
                        });

                      }

                  }


            });


            socket.on('delete message', function(msg){


                $('[data-uid="' + msg.entryuid + '"]').fadeOut();

                $("#statement").val('');

                // When searched for nodes in that statement, nothing will appear.

                nodesOfStatement[msg.entryuid] = [];

                var nodesToKeep = [];

                sigma.graph.edges().forEach(function(e) {

                    // If a node appears in at least one statement, we add him in ToKeep list
                    if (nodesOfStatement[e.statement_id].indexOf(e.source) > -1) {
                        nodesToKeep.push(e.source);
                    }

                    if (nodesOfStatement[e.statement_id].indexOf(e.target) > -1) {
                        nodesToKeep.push(e.target);
                    }

                    var statePosition = statementsOfContext[e.edge_context].indexOf(e.statement_id);
                    if (statePosition < 0) {
                        statementsOfContext[e.edge_context].splice(statePosition, 1);
                    }


                });



                sigma.graph.nodes().forEach(function(n) {
                    if (nodesToKeep.indexOf(n.id) < 0) {
                        sigma.graph.dropNode(n.id);
                    }

                });

                sigma.refresh();

                sigma.startForceAtlas2(forceatlas_options);

                // Don't run it forever not to overheat :)

                setTimeout(function() {

                    sigma.stopForceAtlas2();
                    sigma.killForceAtlas2();

                }, 3000);

                //console.log(newnodes);
                // console.log(msg.graph.edges);
                // console.log(sigma.graph.edges());


            });




        }
);

   var visibleentries_original = '0';

// TODO: 1. Add search function by #hashtag; 2. Attach that same function to hashtag doubleclick;

// Auto-resize to fill content;

    $(document).ready(function(){

      // Get the context names - all the contexts that exist in the graph we just loaded
      // This IF statement is for the case when the contextlist parameter is not passed on
      <% if (contextlist.length > 0) { %>
      <% contextlist.forEach(function(contextlabel) { %>
        contextNames.push("<%= contextlabel %>");
      <% }); %>
      <% } %>


      if (localStorage.getItem('defaultbehavior') == 'add') {
        $('#addnode').addClass('addnode-on');
      }
      else {
        $('#searchnode').addClass('searchnode-on');
      }



      // Put the contexts into the menu
      populateContextMenu(contextNames);

        $('.tooltip').tooltipster({
            theme: 'tooltipster-noir',
            position: 'left',
            maxWidth: 200,
            delay: 1000
        });



        var privacyform = '';

        var graph_share_url = hostsite + '/' + current_user;

        if (current_context) {
            graph_share_url = graph_share_url + "/" + current_context + "?";
        }

        if (background) {
            graph_share_url += 'background=' + background + '&';
        }

        if (most_influential) {
            graph_share_url += '&most_influential=' + most_influential + '&';
        }

        if (maxnodes) {
            graph_share_url += '&maxnodes=' + maxnodes + '&';
        }

        var privacy_iframe = "<iframe width='100%' height='500' style='height: 500px' src='https://" + graph_share_url + "hide_always=1&link_hashtags=1&background=" + background + "&maxnodes=" + maxnodes + "' frameborder='0' allowfullscreen></iframe>";

        <% if (contextpublic && context && !perceivername && entries.length > 0) { %>
            privacyform = $('<span><form action="/context" name="privacycontext" method="post" class="pure-form"><input type="hidden" name="context" value="<%= context %>">This context can be viewed on:<br><input type="text" id="embedurl" size="25" maxlength="80" class="pure-input" value="https://' + graph_share_url + '"><br><br>Embed code for websites:<br><input type="text" id="embedcode" size="25" maxlength="100" class="pure-input" value="' + privacy_iframe + '"><br><br><input type="submit" id="privacybutton" name="privacy" value="make private"></form></span>')

        <% } else if (!perceivername && context && entries.length > 0) { %>
            privacyform = $('<span><form action="/context" name="privacycontext" method="post" class="pure-form"><input type="hidden" name="context" value="<%= context %>">This context is currently private and cannot be seen by the public.<br><br><input type="submit" id="privacybutton" name="privacy" value="make public"></form></span>')
        <% }  %>

        $('#privacy-link').tooltipster({
            theme: 'tooltipster-noir',
            position: 'top-right',
            maxWidth: 220,
            interactive: true,
            content: privacyform,
            functionReady: function() {
                $('#embedurl').focus(function(event) {
                    setTimeout(function() {$('#embedurl').select();}, 0);
                });
                $('#embedcode').focus(function(event) {
                    setTimeout(function() {$('#embedcode').select();}, 0);
                });
            }
        });


        collaborate_message = '<a href="mailto:chat@infranodus.com?subject=Chat%20Now&body=https://' + graph_share_url + '/edit?collaborate=' + collaborate_id + '">Invite us</a> or other people for a real-time constellaversation  just share the link below:<br>';

        collaborate_html = '<span><form class="pure-form">' + collaborate_message + '<input type="text" id="collaburl" size="22" maxlength="80" class="pure-input" value="http://' + graph_share_url + '/edit?collaborate=' + collaborate_id + '"></form></span>';

        collaborate_content = $(collaborate_html);

        $('#collaborate-link').tooltipster({
            theme: 'tooltipster-noir',
            position: 'top-right',
            maxWidth: 220,
            interactive: true,
            content: collaborate_content,
            functionReady: function() {
                $('#collaburl').focus(function(event) {
                    this.setSelectionRange(0, 9999);
                });
            }
        });







        <% if (!perceivername) { %>

            // Advertise graph collaboration module
            if (!collaborate_invite) {
                var collab_content = $('#collaborate-link').tooltipster('content');

                var graph_share_url = hostsite + '/' + current_user;

                if (current_context) {
                    graph_share_url = graph_share_url + "/" + current_context;
                }


            }

        // START Speech Recognition Module only for Chrome

        if ('webkitSpeechRecognition' in window) {

            var recognition = new webkitSpeechRecognition();

            $('#microphone-link').fadeIn();

            if (localStorage.getItem('microphone') == 1) {
                $('#microphone-link').toggleClass('microphone-on', 'add');
                activateVoiceInput();
            }

            if (speech) {
              $('#microphone-link').toggleClass('microphone-on', 'add');

              activateVoiceInput();

              if (walkthrough == "mic") {
              // Instance the walkthrough tour
                var tour = new Tour({
                  storage: false,
                  steps: [
                  {
                    element: "#microphone-link",
                    placement: "left",
                    title: "Turn on Your Microphone",
                    content: "When it's blue, it's on. Make sure you also have the sound and microphone turned on in your computer.",
                    onNext: function (tour) {
                      setTimeout(function() {
                        var player = new talkify.Html5Player(); //or new talkify.Html5Player()
                        player.playText('Please speak into your microphone and every word you say, will be visualized in a network.');
                      },1000);
                    }
                  },
                  {
                    element: "#entryform",
                    title: "Continue Talking...",
                    content: "As you speak, the words will appear here. Please, speak clearly and make breaks between sentences."
                  },
                  {
                    element: ".entry",
                    title: "Edit the Statements",
                    content: "You will see visualization on the right. To delete a statement, double-click it."
                  },
                  {
                    element: "#statement",
                    title: "Delete Statements",
                    content: "If you double-clicked the statement, it appears here. Then simply click the Delete icon below the statement and it will be removed."
                  }
                ]});

                // Initialize the tour
                tour.init();

                // Start the tour
                tour.start();
              }

            }

            $("#microphone-link").click(function(e) {

                e.preventDefault();

                if (localStorage.getItem('microphone')  == 1) {
                    localStorage.setItem('microphone', 0);
                    $('#microphone-link').toggleClass('microphone-on', 'remove');
                    recognition.abort();
                }
                else {
                    localStorage.setItem('microphone', 1);
                    activateVoiceInput();
                    $('#microphone-link').toggleClass('microphone-on', 'add');
                }

            });



        }


            function activateVoiceInput() {



                    var voiceresult = '';

                    var previoustalk = '';

                    var previoustalk_last = '';

                    var offtherecord = '';

                    var voicecorrect = '';

                    // Are we processing a short phrase or performing continuous dictation?
                    recognition.continuous = false;

                    // Do we require interim results in addition to the final results?
                    recognition.interimResults = true;

                    // Check if the user has a preferred language settings

                    if (inlanguage != undefined) {
                        if (inlanguage == 'auto') {
                          recognition.lang = 'en-US';
                        }
                        else {
                          recognition.lang = inlanguage;
                        }
                    }
                    else {
                        // We speak The US English here
                        recognition.lang = 'en-US';
                    }

                    if (language == 'en' || language == 'en-US' || language == 'english') {
                        recognition.lang = 'en-US';
                        localStorage.setItem('language', 'en');
                    }

                    else if (language == 'ru' || language == 'russian') {
                        recognition.lang = 'ru';
                        localStorage.setItem('language', 'ru');
                    }
                    else if (language == 'fr' || language == 'french') {
                        recognition.lang = 'fr';
                        localStorage.setItem('language', 'fr');
                    }
                    else if (language == 'de' || language == 'german') {
                        recognition.lang = 'de';
                        localStorage.setItem('language', 'de');
                    }

                    // if (localStorage.getItem('language') == 'ru') {
                    //     recognition.lang = 'ru';
                    //     localStorage.setItem('language', 'ru');
                    // }
                    // else if (localStorage.getItem('language') == 'en') {
                    //     recognition.lang = 'en';
                    //     localStorage.setItem('language', 'en');
                    // }
                    // else if (localStorage.getItem('language') == 'fr') {
                    //     recognition.lang = 'fr';
                    //     localStorage.setItem('language', 'fr');
                    // }
                    // else if (localStorage.getItem('language') == 'de') {
                    //     recognition.lang = 'de';
                    //     localStorage.setItem('language', 'de');
                    // }

                    // Kick off the Speech to Text recognition process
                    recognition.start();

                    // Set up
                    recognition.onstart = function(event){
                        console.log("onstart", event);
                    }
                    // Set up
                    recognition.onspeechstart = function(event){
                        console.log("onspeechstart", event);
                    }

                    // Process parsed result
                    recognition.onresult = function(event){
                        // console.log("onresult", event);



                        if ($('#statement').val().length == 0) {
                          previoustalk = '';
                        }
                        voiceresult = previoustalk + event.results[0][0].transcript;
                        $('#statement').val(voiceresult);

                        console.log(event.resultIndex);
                        for (var i = event.resultIndex; i < event.results.length; ++i) {
                            if (event.results[i].isFinal) {

                                recognition.abort();

                                lastword = event.results[0][0].transcript.toLowerCase();

                                if (offtherecord == 'on') {
                                    voiceresult = previoustalk;
                                    $('#statement').val(voiceresult);
                                    if (lastword == 'on the record') {
                                      offtherecord = '';
                                    }
                                }
                                else if (voicecorrect == 'on') {
                                  var wordswap = lastword.split(" ");
                                  var wordwas = wordswap[0];
                                  var wordis = wordswap[2];
                                  var reg = new RegExp('('+wordwas+')', 'gi');
                                  voiceresult = previoustalk.replace(reg,wordis);
                                  previoustalk = voiceresult + ' ';
                                  $('#statement').val(voiceresult);
                                  voicecorrect = '';
                                }
                                else {
                                  if (voiceresult.length > 2) {
                                      if (!voice_continues) {

                                        setTimeout(function(){
                                            $('#submitbutton').trigger('click');
                                        }, 1000);
                                      }
                                      else {
                                        if (lastword == voice_continues) {
                                          voiceresult = previoustalk;
                                          previoustalk = '';
                                          $('#statement').val(voiceresult);
                                          setTimeout(function(){
                                              $('#submitbutton').trigger('click');
                                          }, 1000);
                                        }
                                        else if (lastword == 'improve layout') {
                                          voiceresult = previoustalk;
                                          $('#statement').val(voiceresult);
                                          $('#improve-layout').trigger('click');
                                        }
                                        else if (lastword == 'off the record') {
                                          voiceresult = previoustalk;
                                          $('#statement').val(voiceresult);
                                          offtherecord = 'on';
                                        }
                                        else if (lastword == 'correct') {
                                          voiceresult = previoustalk;
                                          $('#statement').val(voiceresult);
                                          voicecorrect = 'on';
                                        }
                                        else if (lastword == 'erase') {
                                          voiceresult = previoustalk_last;
                                          previoustalk = previoustalk_last;
                                          $('#statement').val(voiceresult);
                                        }
                                        else if (lastword == 'new line') {
                                          previoustalk_last = previoustalk;
                                          previoustalk = voiceresult + ' \n';
                                        }
                                        else {
                                          previoustalk_last = previoustalk;
                                          previoustalk = voiceresult + ' ';
                                        }
                                      }
                                  }
                                  else {
                                    previoustalk = voiceresult + ' ';
                                      // recognition.start();
                                  }
                                }
                            }
                        }
                    }

                    // Handle error
                    recognition.onerror = function(event){
                        console.log("onerror", event);
                        if (event.error == 'no-speech') {

                        }
                    }

                  /*  // Housekeeping after success or failed parsing
                    recognition.onspeechend = function(){
                        console.log("onspeechend");
                        if (voiceresult.length > 4) {
                            setTimeout(function(){
                                $('#submitbutton').trigger('click');
                            }, 1000);

                        }
                        else {
                            previoustalk = voiceresult + '';
                            // recognition.start();
                        }

                    }*/


                    recognition.onend = function(){

                        console.log("onend");
                        if (localStorage.getItem('microphone') == 1 || speech == 1) {
                            recognition.start();
                        }

                    }



            }


            // END Speech recognition module





            // IMPORTANT NOTE this is the end of the cycle that shows only to editor
         <% } %>

         // BEGIN WALKTHROUGH Module

         // Basic tutorial
         function initializeWalkthrough () {
           // Instance the tour
             var tour = new Tour({
               storage: false,
               steps: [
               {
                 element: "#entryform",
                 orphan: true,
                 placement: "top",
                 title: "Welcome to InfraNodus",
                 content: "You can start typing your ideas and notes here. Press Enter or Save to submit. They will be visualized as a graph.",
                 onNext: function (tour) {
                     $('#statement').val('Every word you type is a node in a graph. When the words cooccur together, they are connected.');
                 }
               },
               {
                 element: "#statement",
                 placement: "top",
                 title: "Add a Statement...",
                 content: "You can add this statement or edit and add your own. Then press the SAVE button...",
                 onNext: function (tour) {
                     $('#statement').val('');
                 }
               },
               {
                 element: ".entry:first",
                 orphan: true,
                 placement: "auto",
                 title: "See the Statements",
                 content: "You will then see this statement appear here. To edit it, double-click it."
               },
               {
                 element: "#statement",
                 placement: "top",
                 title: "Delete Statements",
                 content: "If you double-clicked the statement, it appears here. Then simply click the Delete icon below the statement and it will be removed. You can also Edit and click Edit. Or Cancel."
               },
               {
                 element: "#import-link",
                 placement: "top",
                 title: "Import Statements",
                 content: "You can also import any data from a PDF / TXT file, a URL (inc Wikipedia), RSS Feeds, Twitter, Google search results, your notes, etc."
               },
               {
                 element: "#menuLink",
                 title: "Context Menu",
                 content: "You can navigate using this menu here. Here you can choose another context (list / graph / set), add a new one, or see all of them at once.",
                 onShow: function (tour) {
                     $('#menuLink').click();
                 }
               },
               {
                 element: "#chat-link",
                 placement: "left",
                 title: "Hide/Show Statements",
                 content: "You can use this button to hide / show statements, so you can clearly see the graph.",
                 onShow: function (tour) {
                     $('#menuLink').click();
                     $('#chat-link').click();
                 }
               },
               {
                 element: "#walkthrough",
                 placement: "left",
                 title: "This Tutorial",
                 content: "If, at any point, you want to see this tutorial again, click here.",
                 onShow: function (tour) {
                     $('#chat-link').click();
                 }
               },
               {
               element: "#addnodeinput",
               placement: "bottom",
               title: "Search in Graph",
               content: "You can also use this search field to look for the nodes in the graph. Once you find the nodes, they will appear below. You can click the 'delete' button to remove them from the graph.",
               },
               {
               element: "#addnode",
               placement: "bottom",
               title: "Add a Node",
               content: "You can use this field to quickly add a node in the graph.",
               },
               {
                 element: "#microphone-link",
                 orphan: true,
                 placement: "left",
                 title: "Voice to Text Input",
                 content: "If you use Chrome browser, you can also turn on Voice to Text input. Great for interviews and when you're lazy to type. English, French, German and Russian."
               },
               {
                 element: "#graph-container",
                 placement: "top",
                 title: "Use the Graph",
                 content: "You can click on the nodes on the graph to see what they're connected to and to filter the statements, which contain them."
               },
               {
                 element: "#analyticsbutton",
                 placement: "left",
                 title: "Text / Graph Analytics",
                 content: "Here you can see the main topics identified in the graph and the main keywords / nodes and click them to get more insights about the graph. You can also discover what questions to ask to make your discourse more connected.",
                 onShow: function (tour) {
                     $('#chat-link').click();
                     if ($('#analytics').is(":visible")) {
                     }
                     else {
                       $('#analyticsbutton').click();
                     }
                 }
               },
               {
                 element: "#analytics",
                 placement: "auto",
                 title: "How to Analyze the Graph",
                 content: "The top topics are identified according to Louvain community detection algorithm (Blondes et al 2008). It detects the words that co-occur more often together than others and puts them into the same community (designated with a specific color)."
               },
               {
                 element: "#analytics",
                 placement: "auto",
                 title: "Most Influential Words",
                 content: "The most influential words are the words in the graph that have the highest betweenness centrality they appear most often on the shortest path between any two randomly chosen words. It means they serve as the 'crossroads' of meaning, often linking different contexts together. This is not the same as the most frequently used words, rather these words connect the different topics in this discourse. (it is also possible to use degree as the most influential words setting)"
               },
               {
                 element: "#graphstats",
                 placement: "top",
                 title: "Graph Stats",
                 content: "We use our own measure of <a href='https://noduslabs.com/research/visualization-text-polysingularity-network-analysis/' target='_blank'>discourse polysingularity</a> (Paranyushkin 2012, 2018) to score the discourse visualized based on the structure of the graph. <br><b>'Sparse'</b>  indicates a fragmented discourse (e.g. poetry, the beginning of a research, etc.) <br><b>'Diversified'</b> indicates a discourse with a high level of plurality.<br><b>'Focused'</b>  prioritizes one or two topics. <br><b>'Biased'</b>  an agenda or mobilizing action present (e.g. advertising, ideology, manifesto)."
               },
               {
                 element: "#graph-container",
                 placement: "bottom",
                 title: "Discover New Ideas",
                 content: "You can also discover new ideas if you look for the gaps inside the graph.",
                 onShow: function (tour) {
                     $('#chat-link').click();
                 }
               },
               {
                 element: "#go_next",
                 placement: "left",
                 title: "Search the Web",
                 content: "Once you select a few nodes in the graph, you can click this to search them on the web.",
                 onShow: function (tour) {
                   if ($('#analytics').is(":visible")) {
                      $('#analyticsbutton').click();
                   }
                 }
               },
               {
                 element: "#collaborate-link",
                 title: "Collaborate",
                 placement: "top",
                 content: "You can invite somebody to collaborate and to work with you on this graph. Click on this button to copy and paste the URL and then send it to your collaborators."
               },
               {
                 element: "#privacy-link",
                 title: "Privacy / Embed",
                 placement: "top",
                 content: "All your data is private by default and cannot be seen by anybody. You can make this graph public and then embed it on any other html page. Just click this button and then copy and paste the URL or the embed code."
               },
               {
                 element: "#settingspane",
                 title: "Settings Pane",
                 content: "Here you can log out, adjust the settings, and export your graph in any format for further visualization using Gephi or any other software.",
                 onShow: function (tour) {
                     $('#menuLink').click();
                 }
               },
               {
                 element: "#addNewContext",
                 title: "Add a New Context",
                 content: "You can add a new context here (click, type in the new name and click Enter to save). Think of contexts as lists or folders. You can store different notes there or you can organize them by hashtags."
               },
               {
                 element: "#improve-layout",
                 title: "Improve Graph Layout",
                 placement: "left",
                 content: "You can use this button to improve the graph's layout.",
                 onShow: function (tour) {
                     $('#menuLink').click();
                 }
               },
               {
                 element: "#graph-tools",
                 placement: "left",
                 title: "Zoom In / Zoom Out",
                 content: "Use these buttons to zoom in and zoom out (or scroll your trackpad or pinch your iPad/iPhone)"
               },
               {
                 element: "#reloadbutton",
                 placement: "left",
                 title: "Reload Graph",
                 content: "If, at any point, something goes wrong, you can always click this to reload the graph."
               },
               {
                 element: "#summary",
                 placement: "bottom",
                 title: "Essence / Summary",
                 content: "Click here to filter the most essential statements from the discourse. These will be the ones that contain the key terms (the main topical clusters) of the discourse as identified in the Analytics pane.",
                 onShow: function (tour) {
                     $('#summary').click();
                     if ($('#analytics').is(":visible")) {
                     }
                     else {
                       $('#analyticsbutton').click();
                     }
                 }
               },
               {
                 element: "#insight",
                 placement: "bottom",
                 title: "Insight",
                 content: "Click here to generate new ideas: we will show you the two topical clusters and the associated statements, which could be linked together to get a new insight into the discourse or to develop it further (depending on its structure).",
                 onShow: function (tour) {
                     $('#insight').click();
                 }
               },
               {
                 element: "#walkthrough",
                 placement: "left",
                 title: "Interactive Help",
                 content: "When you want to see this guide again, click here.",
                 onShow: function (tour) {
                     if ($('#analytics').is(":visible")) {
                        $('#analyticsbutton').click();
                     }
                     $('#overview').click();
                 }
               }

             ]});

             // New context tutorial? Do not show it if it's been shown before
             if (walkthrough == 'newcontext' || walkthrough == 'tldr') {
               tour._options.storage = window.localStorage;
             }

             if (walkthrough == 'tldr') {
             //  console.log(tour._options.steps);
               tour._options.steps = [
                 {
                 element: "#entryform",
                 placement: "right",
                 title: "Visualizing a Long Text",
                 content: "If you would like to visualize a long text, copy and paste it here and click Save. You will probably need to wait for about 20-60 seconds. If nothign happens, you can try to reload the page after. We currently can handle about 150K max.",
               },
               {
               element: "#graph-container",
               placement: "bottom",
               title: "Navigate the Graph",
               content: "You will then see a graph representation of this text. The most prominent topics will be shown as bigger nodes in the graph, those words, which are used in the same context will be closer to each other.",
               },
               {
               element: "#graph-container",
               placement: "top",
               title: "Search through Text",
               content: "You can then click on the nodes in the graph to find the parts of the text that you find interesting.",
               },
               {
               element: "#graph-container",
               placement: "left",
               title: "Discover New Ideas",
               content: "The gaps in the graph will show you where you could do more research or what questions to ask.",
               },
               {
               element: "#graph-container",
               placement: "left",
               title: "Discover New Ideas",
               content: "The gaps in the graph will show you where you could do more research or what questions to ask.",
               },
               {
                 element: "#menuLink",
                 title: "Context Menu",
                 content: "You will be able to later find your text here.",
                 onShow: function (tour) {
                     $('#menuLink').click();
                 }
               },
               {
                 element: "#summary",
                 placement: "bottom",
                 title: "Essence / Summary",
                 content: "Click here to filter the most essential statements from the discourse. These will be the ones that contain the key terms (the main topical clusters) of the discourse as identified in the Analytics pane.",
                 onShow: function (tour) {
                     $('#summary').click();
                     if ($('#analytics').is(":visible")) {
                     }
                     else {
                       $('#analyticsbutton').click();
                     }
                 }
               },
               {
                 element: "#insight",
                 placement: "bottom",
                 title: "Insight",
                 content: "Click here to generate new ideas: we will show you the two topical clusters and the associated statements, which could be linked together to get a new insight into the discourse or to develop it further (depending on its structure).",
                 onShow: function (tour) {
                     $('#insight').click();
                 }
               },
               {
                 element: "#walkthrough",
                 placement: "left",
                 title: "Detailed Tutorial",
                 content: "If, at any point, you want to see a more detailed Tutorial, click here.",
                 onShow: function (tour) {
                     if ($('#analytics').is(":visible")) {
                        $('#analyticsbutton').click();
                     }
                     $('#overview').click();
                 }
               }
               ]
             }

             if (walkthroughtype=='external') {

               var windowsize = $(window).width();
               if (windowsize <= 460) {
                  if (!$("#statements").is(":hidden")) {
                        $('#statements').hide();
                  }

               }

               tour._options.steps = [
               {
               element: "#graph-container",
               placement: "bottom",
               title: "Welcome to InfraNodus",
               content: "Here you can see network visualization of the text on the left. The most prominent topics are shown as the bigger nodes in the graph. The words, which are more often used in the same context will be closer to each other. The different colors will show the topical clusters that belong together.",
               onShow: function (tour) {
                   $('#analytics').hide();
               }
               },
               {
               element: "#graph-container",
               placement: "top",
               title: "Search through Text",
               content: "You can then click on the nodes in the graph to find the parts of the text that you find interesting.",
               },
               {
               element: "#addnodeinput",
               placement: "bottom",
               title: "Search in Graph",
               content: "You can also use this search field to look for the nodes in the graph. Once you find the nodes, they will appear below. You can click the 'delete' button to remove them from the graph.",
               },
               {
                 element: "#chat-link",
                 placement: "left",
                 title: "Hide/Show Statements",
                 content: "You can use this button to hide / show statements, so you can clearly see the graph.",
                 onShow: function (tour) {
                     $('#chat-link').click();
                 }
               },
               {
                 element: "#analyticsbutton",
                 placement: "left",
                 title: "Text / Graph Analytics",
                 content: "Here you can see the main topics identified in the graph and the main keywords / nodes and click them to get more insights about the graph. You can also discover what questions to ask to make your discourse more connected.",
                 onShow: function (tour) {
                     $('#chat-link').click();
                     if ($('#analytics').is(":visible")) {
                     }
                     else {
                       $('#analyticsbutton').click();
                     }
                 }
               },
               {
                 element: "#analytics",
                 placement: "auto",
                 title: "How to Analyze the Graph",
                 content: "The top topics are identified according to Louvain community detection algorithm (Blondes et al 2008). It detects the words that co-occur more often together than others and puts them into the same community (designated with a specific color)."
               },
               {
                 element: "#analytics",
                 placement: "auto",
                 title: "Most Influential Words",
                 content: "The most influential words are the words in the graph that have the highest betweenness centrality they appear most often on the shortest path between any two randomly chosen words. It means they serve as the 'crossroads' of meaning, often linking different contexts together. This is not the same as the most frequently used words, rather these words connect the different topics in this discourse. (it is also possible to use degree as the most influential words setting)"
               },
               {
                 element: "#graphstats",
                 placement: "top",
                 title: "Graph Stats",
                 content: "We use our own measure of <a href='https://noduslabs.com/research/visualization-text-polysingularity-network-analysis/' target='_blank'>discourse polysingularity</a> (Paranyushkin 2012, 2018) to score the discourse visualized based on the structure of the graph. <br><b>'Sparse'</b>  indicates a fragmented discourse (e.g. poetry, the beginning of a research, etc.) <br><b>'Diversified'</b> indicates a discourse with a high level of plurality.<br><b>'Focused'</b>  prioritizes one or two topics. <br><b>'Biased'</b>  an agenda or mobilizing action present (e.g. advertising, ideology, manifesto)."
               },
               {
               element: "#graph-container",
               placement: "bottom",
               title: "Discover the New Ideas",
               content: "The gaps in the graph will show you where you could do more research or what questions to ask."
               },
               {
                 element: "#walkthrough",
                 placement: "left",
                 title: "Detailed Tutorial",
                 content: "If, at any point, you want to see a this Tutorial again, click here.",
                 onShow: function (tour) {
                   if ($('#analytics').is(":visible")) {
                      $('#analyticsbutton').click();
                   }
                 }
               },
               {
                 element: "#menuLink",
                 title: "Create Your Own Graphs",
                 content: "To create your own text network visualizations, you can create a new account on <a href='https://infranodus.com'>InfraNodus.Com</a>.",
               }
               ]
             }

             // Initialize the tour
             tour.init();

             // Start the tour
             tour.start();

           }



           if (walkthrough == 'default' || walkthrough == 'newcontext' || walkthrough == "tldr" || walkthrough == "force") {

             initializeWalkthrough();

           }

           $("#walkthrough").click(function(e) {
               e.preventDefault();
               walkthrough = 'default';
               initializeWalkthrough();
           });


        $("#chat-link").click(function(e) {
            e.preventDefault();

            // The user clicked on the graph icon, so we reset his graph interaction activity for timeout later
            graphInteraction = null;
            clearTimeout(inactiveTimeout);

            toggle_statements();


        });

        $("#deletenodes").on('click', function(e) {
          e.preventDefault;
          socket.emit('node delete', {pinnedNodes: pinnedNodes});
        });

        $("#undo").on('click', function(e) {
          e.preventDefault;
          socket.emit('graph reset');
        });

        $("#stopsave").on('click', function(e) {
          e.preventDefault;
          window.location.href = "/settings?stopwords=" + encodeURIComponent(deletedNodes.join(' ')) + "&returncontext=" + current_context;
        });


        $("#addnode").on('click', function(e) {
          e.preventDefault();

          $('#addnode').addClass('addnode-on');
          $('#searchnode').removeClass('searchnode-on');
          localStorage.setItem('defaultbehavior', 'add');

          document.getElementById('addnodeform').dispatchEvent(new Event('submit'));


        });


        $("#searchnode").on('click', function(e) {
          e.preventDefault();

          $('#addnode').removeClass('addnode-on');
          $('#searchnode').addClass('searchnode-on');
          localStorage.setItem('defaultbehavior', 'search');

          var searchinput = $('#addnodeinput').val();
          // TODO lemmas
          if (searchinput.length > 0) {
              var searchinarray = searchinput.split(' ');
              for (var key in searchinarray) {
                if (searchinarray[key].charAt(0) == '#') { searchinarray[key] = searchinarray[key].slice(1); }
              }
              searchinput = searchinarray.join(' ');
              $('#search').val(searchinput);
              document.getElementById('searchform').dispatchEvent(new Event('submit'));
          }
          else {
            alert('Please, enter the node name you want to find...');
          }

        });

        if (addcontext) {
          $('#addcontext-link').addClass('addcontext-visible');
        }

        $("#addcontext-link").on('click', function(e) {
          e.preventDefault();
          if ($(".addcontext-on").is(":visible")) {
              $('#addcontext-link').removeClass('addcontext-on');
          }
          else {
              $('#addcontext-link').addClass('addcontext-on');
          }


        });


        $('#addnodeform').submit(function(e) {
            e.preventDefault(); // to stop the form from submitting
            if ($(".searchnode-on").is(":visible")) {
              $('#searchnode').trigger('click');
            }
            else {
              if ($('#addnodeinput').val().length > 0) {
                  $('#statement').val($('#addnodeinput').val());
                  document.getElementById('submitform').dispatchEvent(new Event('submit'));
                  $('#addnodeinput').val('');
                  $("#addnodeinput").focus();
              }
              else {
                alert('Please, enter the name of the node you want to add...');
              }
            }

        });



        $("#imports").click(function(e) {
            // var fornode = $('#statement').val();
            // // if (pinnedNodes.length > 0) {
            // //      fornode = toTitleCase(pinnedNodes[pinnedNodes.length - 1].replace(/_/g, " "));
            // // }
            //
            // var current_href = $(this).attr("href");
            // $(this).attr("href",current_href + '&statement=' + fornode);
        });

        $("#finds").click(function(e) {
          $('#deletecontextbutton').hide();
          $('#privacy-link').hide();
          $('#collaborate-link').hide();
          $('#entries').css({height:  $(window).height() - 200});
        });

        $("#adds").click(function(e) {
          $('#deletecontextbutton').show();
          $('#privacy-link').show();
          $('#collaborate-link').show();
          $('#entries').css({height:  $(window).height() - 380});
        });

        $("#import-link").click(function(e) {

          var fornode = $('#statement').val();


          if (pinnedNodes.length > 0) {
               fornode = pinnedNodes.join("+");
          }

          var current_href = $(this).attr("href");

          $(this).attr("href",current_href + '?context=' + current_context + '&fornode=' + fornode);
        });


        function toTitleCase(str)
        {
            return str.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
        }

        // Activate content switcher Set1 and set delay time for fade
        jcps.fader(0, '#switcher-panel', '.set1');

        var uproll = $('#entryform').height();

        if (hide_edit) {
          uproll = 50;
        }

        $('#entries').css({height:  $(window).height() - uproll - 100});

        $(window).resize(function() {
              $('#entries').css({height:  $(window).height() - uproll - 100});
              $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);
        });


        $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);




        $('#switcher-selector').on('click', 'li', function() {


            $('#topmenuitems').each(function() {
                $("li", this).each(function(i) {
                    $(this).removeClass('pure-menu-selected-top');
                });
            });

            this.className = 'pure-menu-selected-top';


            var topmenuaction = $(this).children(":first").attr('id');

            // Repopulate context for addition field if it was the one clicked

            if (topmenuaction == 'adds') {

                current_context_field = [];

                // Are we inside some context already?

                if (document.getElementById('context').value) {
                    current_context_field.push(document.getElementById('context').value);
                    $("#addedContexts").val(document.getElementById('context').value);
                }

                // if not, we're making the 'private' context default
                else {
                    var lastcontexts = [];
                    var laststatement = $(".entry:last").attr('data-uid');
                    console.log(laststatement);
                    for (var key in statementsOfContext) {
                        var reiteratestatements = statementsOfContext[key];
                        for (var i = 0; i< reiteratestatements.length; i++) {
                            if (laststatement == reiteratestatements[i]) {
                                lastcontexts.push(key);
                                console.log(key);
                            }
                        }

                    }
                    if (lastcontexts[0] == 'help') {
                        current_context_field = ['private'];
                        $("#addedContexts").val('private');
                    }
                    else {
                        current_context_field = lastcontexts;
                        $("#addedContexts").val(current_context_field.join());
                    }
                }

                $("#addToContexts").tagHandler({
                    assignedTags: current_context_field,
                    availableTags: contextNames,
                    autocomplete: true,
                    afterAdd: function(tag) {
                        current_context_field.push(tag);
                        $("#addedContexts").val(current_context_field.join());
                        console.log('contexts in cancel field: ' + current_context_field.join());
                    }
                });

                submitFormProcess();


            }


            // Autocomplete for search input
            $("#search").autocomplete({
                source: nodeNames,
                minLength: 1,
                delay: 500,
                messages: {
                    noResults: '',
                    results: function() {}
                },
                select: function(event, ui) {

                    var filter = ui.item.value;



                }

            });



            search_graph();


        });

        // Autocomplete for search input
        $("#search").autocomplete({
            source: nodeNames,
            minLength: 1,
            delay: 500,
            messages: {
                noResults: '',
                results: function() {}
            },
            select: function(event, ui) {
                var filter = ui.item.value;
            }
        });



        search_graph();

        // Make texarea automatically resizeable
        $('textarea').autosize();

        visibleentries_original = $(".entry:visible").length;

        // Statement edit / delete functionality

        var filteringstarted = 0;



        entryClick();

        // If it's NOT some other user watching the graph, then statements can be edited. Otherwise - no.
        <% if (!perceivername) { %>
        entryDoubleClick();





        <% } %>


        // Highlight statement if clicked once






        // Deal with each date

        $(".entry-date").each(function() {
            var convertedTime = timeConverter($(this).text()) ;
            $(this).text(convertedTime);
        });


        function timeConverter(UNIX_timestamp){
            var modTimestamp = UNIX_timestamp.substr(0, UNIX_timestamp.length - 4);
            var time = moment(modTimestamp, 'x').fromNow();
            return time;
        }

        if ((hide_always || hide_edit) && !show_text) {
            toggle_statements();
            //localStorage.setItem('graph', 1);
        }

        if (hide_when_small) {
            if ($('#menuLink').is(':visible')) {
                toggle_statements();
                //localStorage.setItem('graph', 1);
            }

        }

        if (hide_edit) {
          $('.editorpane').each(function() {
            $(this).hide();
          });
        }


// Are we loading the page to only show the graph?

        <% if (background == '1' || background == 'graph') { %>
           // $('#finds').trigger('click');

            toggle_statements();
            //localStorage.setItem('graph', 1);
            graphOnly = 1;
        <% } %>

        if (localStorage.getItem('graph') == 1 && !graphOnly && !hide_always && !hide_when_small) {
            var isHidden__ = $("#statements").is(":hidden");
            if (!isHidden__) {
                $('#statements').fadeOut();
                $("#chat-link").toggleClass('chat-highlight','add');
            }
        }

        socket.on('node click', function(msg){

              pinnedNodes = msg.pinnedNodes;
              splicedNodes = msg.splicedNodes;
              var pinnedIndex = msg.pinnedIndex;

              // Are we clicking the node that was clicked already? Then show all divs
              if (pinnedIndex > -1) {
                    $('.entry').fadeIn(400);
              }


              // Filter statements and select nodes on the graph
              filter_statements(pinnedNodes);

        });

        socket.on('graph reset', function(msg){

              pinnedNodes = [];
              splicedNodes = [];
              notfoundNodes = [];

              $('.entry').fadeIn(400);

              // Filter statements and select nodes on the graph
              filter_statements(pinnedNodes);

        });


        socket.on('node delete', function(msg){

              var nodesToDelete = msg.pinnedNodes;
              var delete_from = msg.delete_from;
              var collectiond = cy.elements();
              var elesss;

              cy.remove(collectiond);

              elesnodes = [];

              // Reiterate nodes and delete all the pinned nodes

              sigma.instances(0).graph.nodes().forEach(function(n) {

                  if (nodesToDelete.indexOf(n.originalLabel) >= 0) {
                    sigma.instances(0).graph.dropNode(n.id);
                    if (deletedNodes.indexOf(n.originalLabel) == -1) {
                      deletedNodes.push(n.originalLabel);
                    }
                  }
                  else {
                    // Add the remaining ones to Cytoscape
                    n.color = n.originalColor;
                    n.label = n.originalLabel;
                    elesnodes.push({
                        group: "nodes",
                        data: { id: n.id, name: n.label}
                    });


                  }
              //n.size = sigma.graph.degree(n.id);

              });

              // Reiterate all the remaining edges and add them to Cytascape
              // TODO this code duplicates from above - move into a function
              sigma.instances(0).graph.edges().forEach(function(e) {

                  var unique_edge_id = '';

                  // Let's see if the edge source in alphabetical order is further than its target and change places

                  if (e.source > e.target) {
                      unique_edge_id = e.target + '-' + e.source;
                  }
                  else {
                      unique_edge_id = e.source + '-' + e.target;
                  }

                    elesnodes.push({
                        group: "edges",
                        data: { id: unique_edge_id, source: e.source, target: e.target }
                    });


              });


              // Betweenness Centrality Calculation using Cytoscape
              elesss = cy.add(elesnodes);


              betweennessCentrality(elesss);

              // Community detect algorithm

              communityDetect();

              // No more pinned nodes

              if (!delete_from) {
                pinnedNodes = [];
              }
              commClicked = [];

              $('.community_node').each(function(){
                $(this).removeAttr('style');
              });

              $('.top_nodes').each(function(){
                $(this).removeAttr('style');
              });

              if (sigma.instances(0).isForceAtlas2Running()) {
                  sigma.instances(0).stopForceAtlas2();
                  sigma.instances(0).killForceAtlas2();
                  setTimeout(function() {
                  sigma.instances(0).startForceAtlas2(forceatlas_options);
                    setTimeout(function() {

                        sigma.instances(0).stopForceAtlas2();
                        sigma.instances(0).killForceAtlas2();

                    }, 5000);
                }, 1000);
              }
              else {

                  sigma.instances(0).startForceAtlas2(forceatlas_options);
                  setTimeout(function() {

                      sigma.instances(0).stopForceAtlas2();
                      sigma.instances(0).killForceAtlas2();

                  }, 5000);

              }


              // Unfliter the nodes
              filter_statements(pinnedNodes, "nodedelete");


              sigma.instances(0).refresh();



        });

        socket.on('node add', function(msg){
              var addingNodes = msg.addingNodes;
              var stoplistNodes = msg.stoplistNodes;

              // Remove the clicked node from the stoplist

              stoplistNodes.splice(stoplistNodes.indexOf(addingNodes), 1);


              sigma.instances(0).graph.addNode({
                  id: nodeIDs[addingNodes],
                  label: addingNodes,
                  originalLabel: addingNodes,
                  size: 16,
                  x: Math.random(),
                  y: Math.random()
              });

              var cyclefinished = 0;
              var edgeproc;

              var nodeIDs_rev = _.invert(nodeIDs);



              for (var i = 0; i < edgesDB.length; i++ ) {
                if (edgesDB[i].source == nodeIDs[addingNodes] || edgesDB[i].target == nodeIDs[addingNodes]) {

                  edgeproc = edgesDB[i];

                  if (stoplistNodes.length > 0) {

                      // Do connections only if target/source is not in the remaining stoplistNodes
                        if (stoplistNodes.indexOf(nodeIDs_rev[edgeproc.source]) < 0 && stoplistNodes.indexOf(nodeIDs_rev[edgeproc.target]) < 0) {

                              sigma.instances(0).graph.addEdge({
                                     id: edgeproc.id,
                                     source: edgeproc.source,
                                     target: edgeproc.target,
                                     weight: edgeproc.weight,
                                     size: edgeproc.weight,
                                     statement_id: edgeproc.statement_id,
                                     edge_context: edgeproc.edge_context
                              });

                          }




                  }
                  else {
                    sigma.instances(0).graph.addEdge({
                           id: edgeproc.id,
                           source: edgeproc.source,
                           target: edgeproc.target,
                           weight: edgeproc.weight,
                           size: edgeproc.weight,
                           statement_id: edgeproc.statement_id,
                           edge_context: edgeproc.edge_context
                    });

                  }
                }
                cyclefinished = cyclefinished + 1;
              }



              if (cyclefinished == edgesDB.length) {
                sigma.instances(0).refresh();
                var collectiond = cy.elements();
                var elessss;

                cy.remove(collectiond);

                elesnodes = [];


                sigma.instances(0).graph.nodes().forEach(function(n) {
                                    elesnodes.push({
                                        group: "nodes",
                                        data: { id: n.id, name: n.label}
                                    });
                });

                sigma.instances(0).graph.edges().forEach(function(e) {

                    var unique_edge_id = '';

                    // Let's see if the edge source in alphabetical order is further than its target and change places

                    if (e.source > e.target) {
                        unique_edge_id = e.target + '-' + e.source;
                    }
                    else {
                        unique_edge_id = e.source + '-' + e.target;
                    }

                      elesnodes.push({
                          group: "edges",
                          data: { id: unique_edge_id, source: e.source, target: e.target }
                      });


                });


                // Betweenness Centrality Calculation using Cytoscape
                elessss = cy.add(elesnodes);


                betweennessCentrality(elessss);

                // Community detect algorithm

                communityDetect("node add", addingNodes);

                sigma.instances(0).refresh();

                  sigma.instances(0).startForceAtlas2(forceatlas_options);
                  // Don't run it forever not to overheat :)

                  setTimeout(function() {

                      sigma.instances(0).stopForceAtlas2();
                      sigma.instances(0).killForceAtlas2();

                  }, 5000);


                filter_statements(stoplistNodes, 'stopwords');


              }






        });




        // Textarea select conversion to hashtags

        // For now it's disabled, but will be enabled for bulk statement correction later

        var getSelected = function(){
            var t = '';
            if(window.getSelection) {
                t = window.getSelection();
            } else if(document.getSelection) {
                t = document.getSelection();
            } else if(document.selection) {
                t = document.selection.createRange().text;
            }
            return t;
        }


        $("#statement").select(function(eventObject) {
            var selectedText = getSelected().toString();

            var statementReplace = $("#statement").val();

            if ((statementReplace.indexOf('@'+selectedText) === -1) && (selectedText !== statementReplace)) {

                var regex = RegExp(selectedText, "g");

                var dasherized = S(selectedText).underscore().chompLeft('_').s;

                // TODO check words for morphology (if found, alert)

                var replacedString = statementReplace.replace(regex,"#" + dasherized).replace(/##/g,'#');
                $("#statement").val(replacedString);
            }

        });

        // Document Ready end

        });










    function dragNodes () {
      var dragListener = sigma.plugins.dragNodes(sigma.instances(0), sigma.instances(0).renderers[0]);
      dragListener.bind('startdrag', function(event) {

      });
      dragListener.bind('drag', function(event) {
        sigma_dragged = 1;
        if (sigma.instances(0).isForceAtlas2Running()) {

          sigma.instances(0).stopForceAtlas2();
          sigma.instances(0).killForceAtlas2();
        }


      });
      dragListener.bind('drop', function(event) {


        // sigma.instances(0).refresh();

        var new_forceatlas_options = forceatlas_options;

        new_forceatlas_options.slowDown = 1000;
        new_forceatlas_options.startingIterations = 0;

        sigma.instances(0).startForceAtlas2(new_forceatlas_options);

        // Don't run it forever not to overheat :)

        setTimeout(function() {

            sigma.instances(0).stopForceAtlas2();
            sigma.instances(0).killForceAtlas2();

        }, 10000);

     });
      dragListener.bind('dragend', function(event) {

      });
    }

    // Calculate Betweenness Centrality

    var bc_nodes_map;

    function betweennessCentrality (eles) {



      var collection = cy.elements();



      var bc = eles.bc({directed: true});


      var bcmin = 1;
      var bcmax = 0;

      var bcmap = [];

      topbc_nodes = [];

      for (var i = 0; i < cy.nodes().length; i++) {

          var nn = eles.getElementById(cy.nodes()[i].data('id'));

          var currentbc = bc.betweennessNormalized(nn);

          bcmap[cy.nodes()[i].data('id')] = currentbc;

          topbc_nodes.push({key: cy.nodes()[i].data('id'), label: cy.nodes()[i].data('name'), bc: currentbc});

          if (bcmin > currentbc && currentbc != 0) {
            bcmin = currentbc;
          }
          else {
            bcmin = 0.00001
          }

          if (bcmax < currentbc) {
            bcmax = currentbc;
          }

      }

      bc_nodes_map = bcmap;

      topbc_nodes = _.sortBy(topbc_nodes, 'bc').reverse().slice(0,5);


      sigma.instances(0).graph.nodes().forEach(function(n) {
        if ((most_influential == 'bc' || most_influential == 'bc2') && topbc_nodes[0].bc > 0) {
          if (bcmap[n.id] == 0) { bcscore = bcmin } else { bcscore = bcmap[n.id] }
          n.size = Math.round(normalize(bcscore, bcmin, bcmax, 5, 35));
          n.bc = currentbc;
        }
        else {
          n.size = sigma.instances(0).graph.degree(n.id);
        }
      });


      top_components = eles.components();

      //sigma.instances(0).refresh();


      console.log(topbc_nodes);

      //console.log(_.first(_.sortBy(bcmap,'degree').reverse(),3);
      // console.log(bcmin);
      // console.log(bcmax);


    }

    // Community Detect Function

    function communityDetect (coming_from, node_origin) {

      var node_data = [];
      sigma.instances(0).graph.nodes().forEach(function(n) {
          node_data.push(n.id);
      });


      var edge_data = [];

      var totaledgescount = 0;

      sigma.instances(0).graph.edges().forEach(function(e) {
          edge_data.push({source: e.source, target: e.target});
          if (e.source != e.target) {
            totaledgescount = totaledgescount + 1;
          }
      });
      if (node_data.length > 0 && edge_data.length > 0) {

      var community = jLouvain().nodes(node_data).edges(edge_data);

      var community_assignment_result = community();
      var node_ids = Object.keys(community_assignment_result['communities']);

      //console.log('Resulting Community Data', community_assignment_result['communities']);
      // console.log('Final Modularity', community_assignment_result['modularity']);


      var max_community_number = 0;

      var top_communities = {};

      sigma.instances(0).graph.nodes().forEach(function(n) {
        n.community = community_assignment_result['communities'][n.id];
        var commune = n.community;
        if (!top_communities[commune]) {
          top_communities[commune] = []
        }
        top_communities[commune].push({id: n.id, name: n.originalLabel, degree: sigma.instances(0).graph.degree(n.id), bc: bc_nodes_map[n.id]});
        max_community_number = max_community_number < community_assignment_result['communities'][n.id] ? community_assignment_result['communities'][n.id]: max_community_number;
      });

    //  console.log(max_community_number);



         var topp_communities = {};

         var all_communities = {};

         for (var indd in top_communities) {
          if (!topp_communities[indd]) {
           topp_communities[indd] = {};
           all_communities[indd] = {};
           topp_communities[indd].id = indd;
           all_communities[indd].id = indd;
           topp_communities[indd].length = top_communities[indd].length;
           all_communities[indd].length = top_communities[indd].length;
           topp_communities[indd].nodes = top_communities[indd];
           all_communities[indd].nodes = top_communities[indd];
          }
         }

         topp_communities = _.sortBy(topp_communities,'length').reverse();
         all_communities = _.sortBy(all_communities,'length').reverse();


         var advice_iterations = 4;
         var recommender_iterations = 2;
         if (topp_communities.length < advice_iterations) {
           advice_iterations = topp_communities.length;
         }

         topp_communities = _.first(topp_communities,advice_iterations);

         var toppp_communities = [];

         // Slice first 3 off every topp community

         for (var j = 0; j < topp_communities.length; j++) {
           if (most_influential == 'bc2') {
             topp_communities[j].nodes = _.first(_.sortBy(topp_communities[j].nodes,'bc').reverse(),3);
           }
           else {
             topp_communities[j].nodes = _.first(_.sortBy(topp_communities[j].nodes,'degree').reverse(),3);
           }
         }

         //console.log(topp_communities);

         // Give it to the global
         most_inf_comm_nodes = topp_communities;

         // these are top nodes in each community
         var top_nodes = [];

         // TODO move parsing logic away from this function


         var recommender_start = 'next idea tip: what is the relation between "';
         var recommender = '';
         var analytics = "<div id='searchanalytics'>The following texts contain the nodes <div id='searchterms'></div><br><div class='headline'>" + current_user + "'s Texts:<br></div>";
         analytics += '<div id="similarlist">n/a</div><br>';
         analytics += "<div class='headline'>Others' Public Texts:<br></div>";
         analytics += '<div id="similaroutside">none found</div><br>&nbsp;';
         analytics += '</div>';

         analytics += "<div id='mininganalytics'><div class='headline'>Main Topics</div> (according to Latent Dirichlet Allocation):<br>";
         analytics += "<div id='topicsLDA'></div><br>";
         analytics += "<div class='headline'>Most Influential Words</div> (main topics and words according to LDA):<br>";
         analytics += "<div id='termsLDA'></div><br>";
         analytics += "LDA works only for English-language texts at the moment. More support is coming soon, subscribe  @noduslabs to be informed.<br><br>";
         analytics += "<button id='miningbutton' class='panelControlBtn' data-id='mining_analytics'>LDA Data</button> <button id='analbutton' class='panelControlBtn' data-id='analytics'>Graph Stats</button>";
         analytics += "</div>";


         analytics = analytics + "<div id='mainanalytics'><div class='headline'>Main Topics</div> (communities detected):<br>"
         analytics += "1: "
         for (var j = 0; j < topp_communities.length; j++) {

            for (var n = 0; n < topp_communities[j].nodes.length; n++) {
                if (recommender_iterations != 0) {
                  recommender += "<a href='#' class='community_node' community='"+topp_communities[j].id+"'>" + topp_communities[j].nodes[n].name +'</a> - ';
                }
                analytics += "<a href='#' class='community_node' community='"+topp_communities[j].id+"'>" + topp_communities[j].nodes[n].name + "</a> <div class='inlinesquare "+(topp_communities[j].id)+"'></div> ";
                top_nodes.push(topp_communities[j].nodes[n].name);
            }
            if (recommender_iterations != 0) {
              recommender = recommender.slice(0, -3);
              if (j != recommender_iterations) {
              recommender += '"</div> and <br><div class="headline">"';
              }
              recommender_iterations = recommender_iterations - 1;
            }
          //  analytics = analytics.slice(0, -3);
            analytics += " <br>" + (j + 2) + ": ";
         }

         //recommender = recommender.slice(0, -10);
         recommender += ''
         analytics = analytics.slice(0, -7);



         // Get the nodes with the highest degree
         var degree_nodes = [];
         sigma.instances(0).graph.nodes().forEach(function(n)  {
            degree_nodes.push({id: n.id, label: n.label, degree: sigma.instances(0).graph.degree(n.id)});
         });

         //console.log(degree_nodes);
         degree_nodes = _.first(_.sortBy(degree_nodes,'degree').reverse(),9).slice(0,4);



        // console.log(top_nodes);
        //console.log(degree_nodes.slice(0,4));



        // TODO to move parsing logic away from this function

         analytics += "<br><br><div class='headline'>Most Influential Words";


         var toppbc_nodes = topbc_nodes.slice(0,4);

         console.log(toppbc_nodes);

         most_inf_nodes = toppbc_nodes;

         // TODO   if (most_influential == 'bc' && toppbc_nodes[0].bc > 0) {


         if ((most_influential == 'bc' || (most_influential == 'bc2') && toppbc_nodes[0].bc > 0)) {
           analytics += '</div> (highest betweenness centrality):<br>';
           for (var ind in toppbc_nodes) {
               if (toppbc_nodes[ind].bc > 0) {

                 analytics += '<div class="inlinesquare '+toppbc_nodes[ind].key+'"></div> <a href="#" class="top_nodes">' + toppbc_nodes[ind].label + '</a> &nbsp;';

               }
           }
           analytics = analytics.slice(0, -7);


         }
         else {
           analytics += '</div> (highest degree):<br>';
           for (var ind in degree_nodes) {
               analytics += '<div class="inlinesquare '+degree_nodes[ind].id+'"></div> <a href="#" class="top_nodes">' + degree_nodes[ind].label + '</a> &nbsp;';
           }
           analytics = analytics.slice(0, -7);


         }

         analytics += "<br><br><div class='headline'>Question to Ask:</div> <br>What is the relation between <br><div class='headline'>\"" + recommender + "\"</div>?";

         analytics += "<br><br><div id='graphstats'></div>";

         analytics += "<br><br><button id='resetgraph' class='panelControlBtn'>Reset</button> &nbsp; <button id='miningbutton' class='panelControlBtn' data-id='mining_analytics'>LDA Data</button> &nbsp; <button id='requestbutton' class='panelControlBtn' data-id='request_analytics'>Custom Report</button>";

         analytics += "</div>";

         // Add control buttons

         analytics = '<div id="panelControllers"><ul><li><button id="analbutton" class="panelControlBtn" data-id="analytics">This Text</li><li><button id="searbutton" class="panelControlBtn" data-id="search_analytics">Related Texts</button></li></ul></div>' + analytics;

         var currentPanel = 'analytics';


          // Check analytics display

         if (!localStorage.getItem('analytics') || localStorage.getItem('analytics') == 1) {


            $('#analytics').html(analytics);
            $('#analytics').show();

            $("#analbutton").css('background','#ffffff');
            $("#searbutton").css('background','#ededed');
            $("#miningbutton").css('background','#ededed');
            $("#resetgraph").css('background','#ededed');


              $('.panelControlBtn').on("click", function() {
                var ID = $(this).attr('data-id');
                if (ID == 'search_analytics') {
                  $("#mainanalytics").fadeOut('fast', function() {
                  $("#mininganalytics").fadeOut('fast');
                  $("#searchanalytics").fadeIn('fast');
                  $("#analbutton").css('background','#ededed');
                  $("#miningbutton").css('background','#ededed');
                  $("#searbutton").css('background','#ffffff');

                  // Show similar texts following a search query on the Connections pane

                  var squery = '';

                  if (pinnedNodes.length > 0) {
                    for (var i = 0; i < pinnedNodes.length; i++) {
                      squery += pinnedNodes[i] + '+';
                    }
                  }
                  else {

                    if ((most_influential == 'bc' || most_influential == 'bc2') && toppbc_nodes[0].bc > 0) {
                      for (var ind in toppbc_nodes) {
                          if (toppbc_nodes[ind].bc > 0) {
                            squery += toppbc_nodes[ind].label + '+';
                          }
                      }
                    }
                    else {
                      for (var ind in degree_nodes) {
                          squery += degree_nodes[ind].label + '+';
                      }
                    }
                  }

                  // Formed search query for JSON GET
                  squery = squery.slice(0, -1);


                  // Add search terms into the Statistics pane
                  $("#searchterms").html('<em>' + squery.replace(/\+/g, ' ') + '</em>');

                  // Request user's context graphs (texts) which contain either the top nodes or the selected ones
                  console.log('<%=perceivername %>'); // public view
                  console.log('<%=receivername %>'); // private view
                  $.getJSON("/api/" + current_user + "/connectedcontexts/?keywords=" + squery + "&user=" + current_user, function( data ) {
                    var items = [];
                    $.each( data.slice(0,7), function( key, val ) {
                      <% if (perceivername) { %>
                      items.push("<a href='/<%= perceivername %>/" + val.name + "?keywords=" + squery + "'>" + val.name + "</a><br>");

                      <% } else  { %>
                      items.push("<a href='/<%= receivername %>/" + val.name + "/edit?keywords=" + squery + "'>" + val.name + "</a><br>");

                      <% } %>
                    });

                    $("#similarlist").html(items.join(""));

                  });

                  // Request user's context graphs (texts) which contain either the top nodes or the selected ones
                  $.getJSON("/api/connectedcontexts/?keywords=" + squery, function( data ) {
                    var items = [];
                    $.each( data.slice(0,7), function( key, val ) {
                      items.push("<a href='/" + val[1] + "/" + val[0].name + "?keywords=" + squery + "'>" + val[0].name + "</a><br>");
                    });

                    $("#similaroutside").html(items.join(""));

                  });

                  });
                  currentPanel = ID;
                }
                else if (ID == 'analytics') {
                  $("#searchanalytics").fadeOut('fast', function() {
                  $("#mininganalytics").fadeOut('fast');
                  $("#mainanalytics").fadeIn('fast');
                  $("#analbutton").css('background','#ffffff');
                  $("#searbutton").css('background','#ededed');
                  $("#miningbutton").css('background','#ededed');
                  });
                  currentPanel = ID;
                }
                else if (ID == 'mining_analytics') {

                  $("#searchanalytics").fadeOut('fast', function() {
                  $("#mainanalytics").fadeOut('fast');
                  $("#mininganalytics").fadeIn('fast');
                  $("#analbutton").css('background','#ededed');
                  $("#searbutton").css('background','#ededed');
                  $("#miningbutton").css('background','#ffffff');

                  var html = "n/a";

                  $.getJSON("/api/" + current_user + "/lda/topics/" + current_context, function( data ) {
                    var items = [];
                    html = '';
                    for (var i = 0; i < data.length; i++) {

                      for (var j = 0; j < data[i].length; j++) {
                        //console.log(nodeIDs[data[i][j].term]);
                        items.push('<div class="inlinesquare ' + community_assignment_result['communities'][nodeIDs[data[i][j].term]] + '"></div> <a href="#" class="top_nodes">' + data[i][j].term + '</a> &nbsp;');
                        if (j == (data[i].length - 1)) {
                          items.push('<br>')
                        }
                      }


                    }


                    $("#topicsLDA").html(items.join(""));

                    $.getJSON("/api/" + current_user + "/lda/terms/" + current_context, function( data ) {
                      var items = [];
                      html = '';
                      for (var i = 0; i < data.length; i++) {

                        for (var j = 0; j < data[i].length; j++) {
                          //console.log(nodeIDs[data[i][j].term]);
                          items.push('<div class="inlinesquare ' + community_assignment_result['communities'][nodeIDs[data[i][j].term]] + '"></div> <a href="#" class="top_nodes">' + data[i][j].term + '</a> &nbsp;');
                          if (j == (data[i].length - 1)) {
                            items.push('<br>')
                          }
                        }


                      }


                      $("#termsLDA").html(items.join(""));

                      for (pall in palette) {
                            if (document.getElementsByClassName("inlinesquare " + pall)) {
                              for (var i = 0; i < document.getElementsByClassName("inlinesquare " + pall).length; i++) {

                                document.getElementsByClassName("inlinesquare " + pall)[i].style.backgroundColor=rgbToHex(palette[pall]._rgb[0],palette[pall]._rgb[1],palette[pall]._rgb[2]);
                              }
                            }
                      }
                      top_nodes_activate();




                    });






                  });



                  });
                  currentPanel = ID;
                }

                else if (ID == 'request_analytics'){
                  window.open('https://noduslabs.com/services/connections/', '_blank');
                }


              });


            //localStorage.setItem('analytics', 1);
            $('#analyticsbutton').addClass('analytics-on');
            $('#analyticscaption').hide();
         }

         else {
           $('#analytics').html(analytics);
           $('#analytics').hide();
           $('#analyticsbutton').removeClass('analytics-on');
           $('#analyticscaption').show();
           $("#miningbutton").css('background','#ededed');

         }

         if ((hide_always || hide_edit) && !show_analytics) {
           $('#analytics').hide();
           $('#analyticsbutton').removeClass('analytics-on');
           $('#analyticscaption').show();
         }

         //console.log(localStorage.getItem('analytics'));

         var recommender_tip = $(recommender).text();

         $("#statement").attr("placeholder", recommender_start + recommender_tip + "?").focus().blur();




    // nice color palette
    if (graphPalette == 'color') {
        var palette = new DistinctColors({count: max_community_number + 1, lightMin: 60, lightMax: 75, chromaMin: 2, chromaMax: 15});
    }
    else if (graphPalette == 'mono') {
    // subdued chromo
        var palette = new DistinctColors({count: max_community_number + 1, lightMin: 40, lightMax: 60, chromaMin: 2, chromaMax: 8});
    //
    }
    // good chromo
    else {
        var palette = new DistinctColors({count: max_community_number + 1, lightMin: 70, chromaMin: 60, samples: 100});
    }

      var s_x = 0;
      var s_y = 0;
      var e_x = 0;
      var e_y = 0;

    //console.log(palette);
    //  console.log(sigma.instances(0).graph.nodes()[54]);


    for (pall in palette) {
          if (document.getElementsByClassName("inlinesquare " + pall)) {
            for (var i = 0; i < document.getElementsByClassName("inlinesquare " + pall).length; i++) {
              document.getElementsByClassName("inlinesquare " + pall)[i].style.backgroundColor=rgbToHex(palette[pall]._rgb[0],palette[pall]._rgb[1],palette[pall]._rgb[2]);
            }
          }
    }

      var totalnodescount = 0;
      var addcontextcount = 0;
      var nodesfirstcom = 0;
      var nodessecondcom = 0;

      var diversityindex = 0;

      var diversity = '';

      var addcontext_nodes = [];


      sigma.instances(0).graph.nodes().forEach(function(n) {
        if (top_nodes.indexOf(n.originalLabel) != -1) {

        }

        community_of_node[n.originalLabel] = n.community;

        n.originalColor = rgbToHex(palette[n.community]._rgb[0],palette[n.community]._rgb[1],palette[n.community]._rgb[2]);

        if (pinnedNodes.indexOf(n.originalLabel) < 0) {

              if (selectedNodes.length > 0){
                if (selectedNodes.indexOf(n.originalLabel) > -1) {
                  n.color = rgbToHex(palette[n.community]._rgb[0],palette[n.community]._rgb[1],palette[n.community]._rgb[2]);
                }
                else if (coming_from == 'node add' && n.originalLabel == node_origin) {
                  n.color = deselected_nodes_color;
                }
                else if (!nodeIDs[n.originalLabel]) {
                  n.color = rgbToHex(palette[n.community]._rgb[0],palette[n.community]._rgb[1],palette[n.community]._rgb[2]);
                }
              }
              else {
                n.color = rgbToHex(palette[n.community]._rgb[0],palette[n.community]._rgb[1],palette[n.community]._rgb[2]);
              }

        }

        if (!nodeIDs[n.originalLabel]) {
          nodeIDs[n.originalLabel] == n.id;
        }

        if (n.community == topp_communities[0].id) {
        //  console.log(n.originalLabel + ' ' + n.x);
        // TODO here we can calculate modularity
            s_x += n.x;
            s_y += n.y;
          //  console.log(s_x)
          nodesfirstcom = nodesfirstcom + 1;
        }
        if (topp_communities[1]) {
        if (n.community == topp_communities[1].id) {
          e_x += n.x;
          e_y += n.y;

          nodessecondcom = nodessecondcom + 1;
        }
        }

        totalnodescount = totalnodescount + 1;

        if (document.getElementsByClassName("inlinesquare " + n.id)[0] != undefined) {
              document.getElementsByClassName("inlinesquare " + n.id)[0].style.backgroundColor=rgbToHex(palette[n.community]._rgb[0],palette[n.community]._rgb[1],palette[n.community]._rgb[2]);
        }

        // Check if the node is in additional context and if yes, give it a different color

        if (contextNodeID[addcontext] && contextNodeID[current_context]) {
              if (interpret) {
                if (contextNodeID[current_context].indexOf(n.id) > -1) {
                    n.originalColor = '#90909f';

                    if (pinnedNodes.indexOf(n.label) == -1) {
                      if (selectedNodes.length > 0){
                        if (selectedNodes.indexOf(n.originalLabel) > -1) {
                        }
                      }
                      else {
                      n.color = '#90909f';
                      }
                    }
                }
                if (contextNodeID[addcontext].indexOf(n.id) > -1 && contextNodeID[current_context].indexOf(n.id) == -1) {
                    addcontextcount = addcontextcount + 1;
                    addcontext_nodes.push({id: n.id, label: n.originalLabel, size: n.size, community: n.community});
                }
              }
              else {
                if (!missing) {
                  if (contextNodeID[addcontext].indexOf(n.id) > -1 && contextNodeID[current_context].indexOf(n.id) == -1) {
                      n.originalColor = color_addcontext;
                      n.color = color_addcontext;
                      addcontextcount = addcontextcount + 1;
                      addcontext_nodes.push({id: n.id, label: n.originalLabel, size: n.size, community: n.community});
                  }
                }
                else {
                  if (contextNodeID[addcontext].indexOf(n.id) == -1 && contextNodeID[current_context].indexOf(n.id) > -1) {
                      n.originalColor = color_addcontext;
                      n.color = color_addcontext;
                      addcontextcount = addcontextcount + 1;
                      addcontext_nodes.push({id: n.id, label: n.originalLabel, size: n.size, community: n.community});

                  }
                }
              }

        }


      });

      // console.log(nodesfirstcom);
      // console.log(nodessecondcom);
      // console.log(totalnodescount);
      // console.log(top_communities);

     addcontext_nodes = _.sortBy(addcontext_nodes, 'size').reverse();

     diversityindex = ((((nodesfirstcom) / totalnodescount).toFixed(2))*100).toFixed(0);


     var graph_density;
     if ((totalnodescount - 1) == 0 || totalnodescount == 0) { graph_density = 0 } else {
      graph_density  = ((totaledgescount) / ((totalnodescount)*(totalnodescount - 1))).toFixed(3);
    }



     var diversitytext = '<div class="headline">Stats:</div> total ' + totalnodescount + ' words, graph density ' + graph_density + ', ';

     diversitytext += 'average degree: ' + (totaledgescount / totalnodescount).toFixed(2);

     var diversity_score = 0;

     // TODO add degree distribution to the indexOf maybe through entropy of degree by nodes

     var bc_dist = [];

     // For every top BC node

    for (var bcid in toppbc_nodes) {
       if (toppbc_nodes[bcid].bc > 0) {

       for (var comid in all_communities) {
          // Open first community

              //  For every node in that community

                  for (var ccnodes in all_communities[comid].nodes) {

                      // If the node's ID equals to the current BC node, add the marker
                      if (all_communities[comid].nodes[ccnodes].id == toppbc_nodes[bcid].key) {
                        bc_dist.push(all_communities[comid].id);
                      }

                  }
       }
       }

    }

     console.log(bc_dist);

     var bc_dist_string = bc_dist.join('');

     // Max entropy for a set of 4 elements is 2

     var bc_entropy = shannon(bc_dist_string);

     // TODO fix bug for two-digit communities

     console.log('BC Entropy: ' + bc_entropy);

     var most_num_comm = [];

     top_components = _.sortBy(top_components, 'length').reverse();

     var num_nodes_component = ((top_components[0].nodes().length / totalnodescount).toFixed(2)*100).toFixed(0);

     if ((community_assignment_result['modularity'] > 0.65 && diversityindex < 50) && ((bc_entropy >= 1.5) || (bc_entropy == 0 && toppbc_nodes[0].bc == 0) || (bc_entropy == 0 && num_nodes_component < 40))) {
        diversity_score = 'Dispersed';
     }
     else if ((community_assignment_result['modularity'] > 0.4 && diversityindex < 50) && ((bc_entropy >= 1.5) || (bc_entropy == 0 && toppbc_nodes[0].bc == 0) || (bc_entropy == 0 && num_nodes_component < 40))) {
        diversity_score = 'Diversified';
     }
     else if ((community_assignment_result['modularity'] < 0.4 && community_assignment_result['modularity'] > 0.2 && bc_entropy >= 0.5) || ((community_assignment_result['modularity'] > 0.4 && diversityindex >= 50)  && bc_entropy >= 0.5) || (community_assignment_result['modularity'] > 0.4 && diversityindex < 50 && bc_entropy > 0.5)) {
        diversity_score = 'Focused';
     }
     else {
        diversity_score = 'Biased';
     }
     // Set global parameter
     polysingularity_score = diversity_score;


     diversitytext +=  ' <br><div class="headline">Discourse structure: <i>' + diversity_score + '</i> &nbsp;&nbsp;[<a href="https://noduslabs.com/research/visualization-text-polysingularity-network-analysis/" target="_blank">?</a>]</div><br>';
     diversitytext += community_assignment_result['modularity'].toFixed(2) + ' modularity, ';
     diversitytext +=  diversityindex + '% of words in the top topic ';

     diversitytext += '(total ' + all_communities.length + ' topics), ';

          if (addcontextcount > 0) {


            if (addcontext_nodes.length > 0) {
              var addcontext_text = '<div class="headline">In ' + addcontext + ' but not in ' + current_context + ':</div> ';
              if (addcontext_nodes.length > 4) {
                addcontext_nodes = addcontext_nodes.slice(0, 4);
              }
              for (var nnn = 0; nnn < addcontext_nodes.length; nnn++) {
                addcontext_text += '<a href="#" class="top_nodes">' + addcontext_nodes[nnn].label + '</a> - ';
              }
              addcontext_text = addcontext_text.slice(0, -3);
              addcontext_text += '<br><br>'
              diversitytext = addcontext_text + diversitytext;
            }
            var addindex = ((((totalnodescount - addcontextcount) / totalnodescount).toFixed(2))*100).toFixed(0);
            diversitytext += 'context ' + addcontext + ' uses ' + addindex + '% words from ' + current_context + ', ';
          }



     diversitytext += num_nodes_component + '% in the main connected component '


     diversitytext += '(' + top_components.length + ' in total), ';

     diversitytext += 'influence dispersal ' + ((bc_entropy/2).toFixed(1)*100).toFixed(0) + '%';


     $('#graphstats').html(diversitytext);

     //sigma.instances(0).refresh;



     //console.log(top_communities);
     //console.log(sigma.instances(0).graph.nodes());
}








      var commClicked = [];

        top_nodes_activate();

        $('#resetgraph').click(function(){
          sigma.instances(0).graph.nodes().forEach(function(n) {
                  n.color = n.originalColor;
                  n.label = n.originalLabel;
          });
          pinnedNodes = [];
          commClicked = [];

          $('.community_node').each(function(){
            $(this).removeAttr('style');
          });

          $('.top_nodes').each(function(){
            $(this).removeAttr('style');
          });

          filter_statements(pinnedNodes);
          sigma.instances(0).refresh();
        });







      function componentToHex(c) {
          var hex = c.toString(16);
          return hex.length == 1 ? "0" + hex : hex;
      }

      function rgbToHex(r, g, b) {
          return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
      }



      // communityDetect function ends here
    }


    function entryClick () {

        $(".entry").on('click', function(e) {
            if (e.target.className == 'app-link-menu') {

                if ($(this).find('.app-link-menu').text() == 'hide filtered') {
                    $(this).find('.nonmatched-sentence').fadeOut(400);
                    $(this).find('.app-link-menu').text('show filtered');
                }
                else {
                    $(this).find('.nonmatched-sentence').fadeTo(400, '0.4');
                    $(this).find('.app-link-menu').text('hide filtered');
                }

            }


            // A parameter to check if we're taking off the flag

            var alreadyClicked = null;

            // Make all entries semitrasparent


            if (pinnedNodes.length == 0) {

                $(".entry").each(function() {
                    if ($(this).css('opacity') < 1) {
                        $(this).css('opacity', '1');
                        alreadyClicked = 1;
                    }
                    else {
                        $(this).css('opacity', '0.3');
                    }
                });

                // The one clicked is not transparent

                $(this).css('opacity','1');

            }



            var keepStatementID = e.currentTarget.dataset.uid;


            console.log(keepStatementID);

            // Make only those edges visible that belong to the statement selected

            if (!alreadyClicked && pinnedNodes.length == 0) {

                sigma.instances(0).graph.edges().forEach(function(e) {

                    if (e.statement_id == keepStatementID) {
                        e.color = e.originalColor;
                    }
                    else {
                        e.color = deselected_nodes_color;
                    }

                });

                // Make only those nodes visible that belong to the statement selected

                sigma.instances(0).graph.nodes().forEach(function(n) {

                    // Is there no contexts at all? Show the node.
                    if (nodesOfStatement[keepStatementID].indexOf(n.id) < 0)  {
                        n.color = deselected_nodes_color;
                        n.label = '';
                    }
                    else {
                        n.color = n.originalColor;
                        n.label = n.originalLabel;
                    }
                });
            }
            else if (e.target.className == 'app-link-menu') {

                // Do nothing

            }
            else {

                if (pinnedNodes.length == 0) {
                    sigma.instances(0).graph.edges().forEach(function(e) {
                        e.color = e.originalColor;
                    });

                    // Make only those nodes visible that belong to the statement selected

                    sigma.instances(0).graph.nodes().forEach(function(n) {
                        n.color = n.originalColor;
                        n.label = n.originalLabel;
                    });
                }

            }

            sigma.instances(0).refresh();
        });

    }



    function entryDoubleClick() {

        $(".entry").on('doubletap', function(e) {

        e.preventDefault();

        // Get the content from the form edit and copy it into the switcher panel to show to the user

        var _formcontent = $('#adds-content').html();

        $("#switcher-panel").html(_formcontent);

        // Get the statement into the edit box at the top
        $("#statement").val($('.entry-text', e.currentTarget).text());

        // Retrieve that statement's ID into the hidden field (for edit or delete)
        $('input[name="statementid"]').val(e.currentTarget.dataset.uid);

        // Retrieve the date of the statement
        $('input[name="timestamp"]').val(e.currentTarget.dataset.timestamp);

        $('#topmenuitems').each(function() {
            $("li", this).each(function(i) {

                $(this).removeClass('pure-menu-selected-top');

            });
        });




        // Change / add buttons
        $('#submitbutton').hide();

        if (!$('#deletebutton').val()) {

            $("#submitform").append('<input type="submit" name="edit" value="edit" id="editbutton" class="pure-button"> <input type="submit" style="margin: 0px 8px;" name="delete" value="delete" id="deletebutton" > <input type="submit" name="cancel" value="cancel" id="cancelbutton" class="pure-button">');

            $('#deletecontextbutton').hide();
            $('#privacy-link').hide();
            $('#collaborate-link').hide();


            // Delete text from the form in case of Cancel, remove the buttons

            $("#cancelbutton").on('click', function(e) {

                e.preventDefault();

                $("#statement").val('');
                $('#editbutton').remove();
                $('#deletebutton').remove();
                $('#cancelbutton').remove();
                $('#submitbutton').show();
                $('#deletecontextbutton').show();
                $('#privacy-link').show();
                $('#collaborate-link').show();

                $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);

                $('input[name="timestamp"]').val('');

                // Populate contexts list next to statement add

                current_context_field = [];

                // Are we inside some context already?

                if ($("#context").val()) {
                    current_context_field.push($("#context").val());
                    $("#addedContexts").val($("#context").val());
                }

                else {

                    if (document.getElementById('context').value) {
                        current_context_field.push(document.getElementById('context').value);
                        $("#addedContexts").val(document.getElementById('context').value);
                    }

                    // if not, we're making the 'private' context default
                    else {
                        var lastcontexts = [];
                        var laststatement = $(".entry:last").attr('data-uid');
                        console.log(laststatement);
                        for (var key in statementsOfContext) {
                            var reiteratestatements = statementsOfContext[key];
                            for (var i = 0; i< reiteratestatements.length; i++) {
                                if (laststatement == reiteratestatements[i]) {
                                    lastcontexts.push(key);
                                    console.log(key);
                                }
                            }

                        }
                        if (lastcontexts[0] == 'help') {
                            current_context_field = ['private'];
                            $("#addedContexts").val('private');
                        }
                        else {
                            current_context_field = lastcontexts;
                            $("#addedContexts").val(current_context_field.join());
                        }
                    }


                }



                $("#addToContexts").tagHandler({
                    assignedTags: current_context_field,
                    availableTags: contextNames,
                    autocomplete: true,
                    afterAdd: function(tag) {
                        current_context_field.push(tag);
                        $("#addedContexts").val(current_context_field.join());
                        console.log('contexts in cancel field: ' + current_context_field.join());
                    }
                });

                // TODO a better way of dealing with delete and edit - in the logic of everything else

                submitFormProcess();





            });

            $("#deletebutton").on('click', function(e) {
                e.preventDefault();

                $('#statement').addClass('loading');

                $('#deletebutton').attr('disabled', 'disabled');

                $('input[name="timestamp"]').val('');


                var formSubmit = $("#submitform").serialize() + '&delete=delete';

                $.post('/post', formSubmit)
                        .done(function(res) {
                            //3. Receive the server response, no need to emit an event
                            console.log(res);
                            if (res.successmsg) {
                                //4. Show the updated text
                                selfPosted = '1';
                                $('#statement').removeClass('loading');
                                $('#deletebutton').removeAttr('disabled');
                                socket.emit('delete message', {entryuid: res.statementid});
                                $("#warnings").append('<p class="warning">The statement was deleted.</p>');
                                $("#warnings").slideDown('slow');
                                $('#cancelbutton').trigger('click');
                                setTimeout(function() {
                                    $("#warnings").slideUp('slow');
                                    $("#warnings").text('');
                                },2000);


                            }
                            else if (res.errormsg) {
                                alert(res.errormsg);
                            }
                            else {
                                alert('Something went wrong, please, try again...');
                            }
                        })
                        .fail(function(res) {
                            alert("Server Error: " + res.status + " " + res.statusText);
                        });



            });

            $("#editbutton").on('click', function(e) {
                e.preventDefault();

                $('#statement').addClass('loading');

                $('#editbutton').attr('disabled', 'disabled');

                var statementToHide = $('#statementid').val();

                $('[data-uid="' + statementToHide + '"]').slideUp();

                var formSubmit = $("#submitform").serialize() + '&edit=edit';

                $.post('/post', formSubmit)
                        .done(function(res) {
                            //3. Receive the server response, no need to emit an event
                            if (res.entryuid) {
                                //4. Show the updated text
                                selfPosted = '1';
                                $('#statement').removeClass('loading');
                                $('#editbutton').removeAttr('disabled');
                                $('#cancelbutton').trigger('click');
                                socket.emit('chat message', {entryuid: JSON.parse(res.entryuid).data, entrytext: res.entrytext, graph: res.graph});
                            }
                            else if (res.errormsg) {
                                alert(res.errormsg);
                            }
                            else {
                                alert('Something went wrong, please, try again...');
                            }
                        })
                        .fail(function(res) {
                            alert("Server Error: " + res.status + " " + res.statusText);
                        });



            });



        }


        current_context_field = [];

        for (var key in statementsOfContext) {
            var checkstatements = statementsOfContext[key];
            for (var l = 0; l<checkstatements.length; l++) {
                if (checkstatements[l] == e.currentTarget.dataset.uid) {
                    current_context_field.push(key);
                }
            }

        }

        console.log('context of statement clicked: ' + current_context_field);

        // Which contexts the statement should be in?
        $("#addedContexts").val(current_context_field.join());

        // Update the contexts list if anything changes in the context settings of the statement

        $("#addToContexts").tagHandler({
            assignedTags: current_context_field,
            availableTags: contextNames,
            autocomplete: true,
            afterAdd: function(tag) {
                current_context_field.push(tag);
                $("#addedContexts").val(current_context_field.join());
                console.log('contexts in statement field: ' + current_context_field.join());
            }
        });


        // Smoothly scroll up
        $("html, body").animate({ scrollTop: 0 }, "slow");


        // THIS WAS BEFORE WHEN YOU CLICK A STATEMENT ONCE

        // Shall all statements inside Entry if clicked




    });
    }


    // Summary and Insight statements

    var summary_statements = [];


    function filter_statements_summary(top_words, top_community_words, filter_origin) {
      console.log('Filering Summary top words');
      console.log(top_words);
      console.log(top_community_words);

      // Let's first filter statements that contain all the most influential top_words
      // If all 4 are nowhere to be found, we reiterate until at least the first 3, 2, 1 is found.
      // Save that

      var found_statements = [];

      var com_statements = {0:[],1:[],2:[],3:[],4:[]};

      var current_community;

      var entries_shown = [];

      var entries_ids = [];
      var entries_keywords = [];


      if (filter_origin == 'insight') {


          for (var i = 0; i < top_community_words.length; i++) {

            current_community = i;
            find_statement(top_community_words[i].nodes,1+i);
          }

      }
      else {

          find_statement(top_words,0);
      }

      function find_statement(key_terms, sweetch) {

          var nodesfound = 0;

          // Find the first entry that contains ALL the key_terms

          $(".entry").each(function(){

            if ((found_statements.length < 1 && sweetch == 0) || (sweetch > 0 && com_statements[sweetch].length < 1)) {

              var currentDiv = $(this).attr('data-uid');


              var originaltext = $(this).children('.entry-text').html();
              var statement_hashtags = $(this).attr('data-hashtags');
              var currentTimecode = $(this).attr('data-timestamp');

              for (var j = 0; j < key_terms.length; j++) {



                var search_lemma;
                  //TODO lemmas
                  // var search_lemma = window.jstemmer(pinnedNodes[j]);

                  if (sweetch == 0) {
                   search_lemma = key_terms[j].label;
                  }
                  else {
                    search_lemma = key_terms[j].name;
                  }

                    if (statement_hashtags.toLowerCase().indexOf(search_lemma.toLowerCase()) > -1) {
                        nodesfound = nodesfound + 1;
                    }

                    if (nodesfound == key_terms.length) {
                      if (sweetch == 0) {
                        found_statements.push({text: originaltext, id: currentDiv, time: currentTimecode, origin: key_terms});
                      }
                      else if (sweetch > 0) {
                        com_statements[sweetch].push({text: originaltext, id: currentDiv, time: currentTimecode, origin: key_terms});
                      }

                    }

                    // If not all the search words are present in an entry, nullify the counter
                    if ((j == key_terms.length - 1) && nodesfound != key_terms.length) {
                      nodesfound = 0;
                    }

              }
            }

          });



          // Ok, did we already find an entry where all the top_words exist?

          if ((sweetch == 0 && nodesfound == top_words.length)) {

                console.log('Found influential node statement:');
                console.log(found_statements);

                for (var s = 0; s < found_statements.length; s++) {
                    entries_shown.push(found_statements[s]);
                }

                nodesfound = 0;

                // Ok, now let's search through each community


                for (var i = 0; i < top_community_words.length; i++) {


                  current_community = i;
                  find_statement(top_community_words[i].nodes,1+i);

                  // TODO for when 3 words are not found

                  // if (nodesfound == top_community_words[i].nodes.length) {
                  //   console.log('found community statemenets');
                  //   console.log(a_statements);
                  // }
                  // else {
                  //   top_community_words[i].nodes = top_community_words[i].nodes.slice(0,-1);
                  //   find_statement(top_community_words[i].nodes,1+i);
                  // }
                }


          }
          else if (sweetch > 0 && nodesfound == key_terms.length) {

            // Did we reach the end of all the words?

            if (current_community == top_community_words.length -1) {


              function cleanup(obj) {
                  let newObj = [];
                  let idx = 0;
                  for (var propName in obj) {
                    let prop = obj[propName];

                    if (prop !== null
                     && prop !== undefined
                     && JSON.stringify(prop) != "[]" // not empty array
                     && JSON.stringify(prop) !== "{}") { // not empty obj
                      newObj[idx] = prop[0]; // we only need one object, NOTE can be an array if we decide to get more statemetns for each community
                      idx++;
                    }
                  }
                  return newObj;
              }

              com_statements = cleanup(com_statements);

              console.log('Main cluster topics:');
              console.log(com_statements);


              for (var s = 0; s < com_statements.length; s++) {
                entries_shown.push(com_statements[s]);
              }


              function compare(a,b) {
                if (a.time < b.time)
                  return -1;
                if (a.time > b.time)
                  return 1;
                return 0;
              }

              entries_shown.sort(compare);
              console.log(entries_shown);

              for (var s = 0; s < entries_shown.length; s++) {
                entries_ids.push(entries_shown[s].id);
                entries_keywords[entries_shown[s].id] = entries_shown[s].origin;
              }

              var most_inf_nodes_str = '';
              console.log('mostinfnodes')
              console.log(most_inf_nodes);
              for (var l = 0; l < most_inf_nodes.length; l++) {
                most_inf_nodes_str += most_inf_nodes[l].label;
                if (l < most_inf_nodes.length - 1) {
                  most_inf_nodes_str += ', ';
                }
              }


              $('.entry').hide();

              var explanation_html = 'The excerpts from the text containing the main topics and the most influential terms:';

              if (filter_origin == 'insight') {
                if (polysingularity_score == 'Dispersed') {
                  explanation_html = "This discourse's structure is <strong>" + polysingularity_score + "</strong>. <br><br>To increase coherency, you can make connections between different separated clusters of key terms and statements. For example, the ones below:";
                }
                else if (polysingularity_score == 'Diversified') {
                  explanation_html = "This discourse's structure is <strong>" + polysingularity_score + "</strong>. It has a balanced representation of several perspectives. <br><br>You can make it more focused if you develop the ideas around the main keywords  <strong>" + most_inf_nodes_str + "</strong>  or by identifying the structural gaps between the less represented clusters and making new connections between them (to focus) or going deeper into them (to diversify even more). Like the ones below:";
                }
                else if (polysingularity_score == 'Focused') {
                  explanation_html = "This discourse's structure is <strong>" + polysingularity_score + "</strong>. While it has several perspectives, it is focused on one. <br><br>You can make it more diversified if you identify the structural gaps in the graph and make connections between themthat's where the new ideas may be. For example, these two sets of key terms and statements below:";
                }
                else if (polysingularity_score == 'Biased') {
                  explanation_html = "This discourse's structure is <strong>" + polysingularity_score + "</strong>. It's leaning towards and promotes a certain perspective, circulating around the most influential words <strong>" + most_inf_nodes_str + "</strong>. <br><br>You could further develop and make connections between the different perspectives (indicated with colored topical clusters) into this discourse to make it more diversified. For example, the ones below:";
                }
                // There is a structural gap and a potential for a new idea between these two sets of key terms and statements below:
              }

              $('#explanation').show();
              $('#explanation').html(explanation_html);

              $(".entry").each(function(){

                  var currentDiv = $(this).attr('data-uid');
                  if (entries_ids.includes(currentDiv)) {

                    $(this).fadeIn(400);

                  // TODO clear up the entry text like in the above -
                  // 1. break into sentences; 2. find the first concentrate pf words; 3. keep it. 4. either create new ones or div the part non-relevant and make it opacity low or remove fully

                    var summary_helper = '';

                    for (var l = 0; l < entries_keywords[currentDiv].length; l++) {


                        if (summary_helper.length > 0) {
                          summary_helper += ', '
                        }
                        if (entries_keywords[currentDiv][l].label) {
                          summary_helper += '<a href="#" class="top_nodes">' + entries_keywords[currentDiv][l].label + '</a>';
                        }
                        else if (entries_keywords[currentDiv][l].name) {
                          summary_helper += '<a href="#" class="community_node" community="' + community_of_node[entries_keywords[currentDiv][l].name] + '">' + entries_keywords[currentDiv][l].name + '</a>';
                        }

                    }

                    if($(this).find('.summary').length == 0){


                      $(this).prepend( "<div class='summary'>key terms: " + summary_helper + "</div>" );

                      //console.log(entries_keywords[currentDiv]);
                    }

                  }

              });



              document.getElementById('entries').scrollTop = 0;
              top_nodes_activate();

              console.log('top info');
              console.log(top_community_words);


              $('#finds').trigger('click');


              // Make only those edges visible that belong to the statement selected

              if (pinnedNodes.length == 0) {


                  sigma.instances(0).graph.edges().forEach(function(e) {

                      if (entries_ids.includes(e.statement_id)) {
                          e.color = e.originalColor;
                      }
                      else {
                          e.color = deselected_nodes_color;
                      }

                  });

                  // Make only those nodes visible that belong to the statement selected
                  sigma.instances(0).graph.nodes().forEach(function(n) {

                      // Is there no contexts at all? Show the node.
                      for (var g = 0; g < entries_ids.length; g++) {
                        if (!n.marked || n.marked == '0') {
                          if (nodesOfStatement[entries_ids[g]].indexOf(n.id) < 0)  {
                              n.color = deselected_nodes_color;
                              n.label = '';
                          }
                          else {
                              n.color = n.originalColor;
                              n.label = n.originalLabel;
                              n.marked = '1';
                          }
                        }
                      }
                  });
                  sigma.instances(0).refresh();

              }



            }

          }
          else {
            // All top nodes cannot be found anywhere, so we cut the list and search again
            if (sweetch == 0) {
              top_words = top_words.slice(0, -1);
              find_statement(top_words,0)
            }
            else if (sweetch > 0) {
                var reduced_query = key_terms.slice(0,-1);
                find_statement(reduced_query,sweetch);
              }
          }


      }


    }

    function top_nodes_activate() {
      $('.top_nodes').click(function(){
        var nodeLabel = $(this).text();


        if (pinnedNodes.indexOf(nodeLabel) < 0) {
            pinnedNodes.push(nodeLabel);
            $(this).attr('style','color: #0089e0 !important; text-decoration: underline !important;');
        }
        else {
            var pinnedIndex = pinnedNodes.indexOf(nodeLabel);
            if (pinnedIndex > -1) {
                pinnedNodes.splice(pinnedIndex,1);
                $(this).removeAttr('style');
                $('.entry').fadeIn(400);
            }

        }

        // console.log("node clicked, now will filter for nodes " + pinnedNodes);
        socket.emit('node click', {pinnedNodes: pinnedNodes, splicedNodes: splicedNodes, nodeLabel: nodeLabel, pinnedIndex: pinnedIndex});


        // Now show / hide statements that have the search field

        filter_statements(pinnedNodes);
        return false;

      });
      var commClicked = [];
      $('.community_node').click(function(){
            var communityClicked = $(this).attr('community').toString();

            var nodeLabel = $(this).text();

            if (pinnedNodes.indexOf(nodeLabel) < 0) {
                pinnedNodes.push(nodeLabel);
                $(this).attr('style','color: #0089e0 !important; text-decoration: underline !important;');
            }
            else {
                var pinnedIndex = pinnedNodes.indexOf(nodeLabel);
                if (pinnedIndex > -1) {
                    pinnedNodes.splice(pinnedIndex,1);
                    $(this).removeAttr('style');
                    $('.entry').fadeIn(400);
                }

            }




          //  socket.emit('node click', {pinnedNodes: pinnedNodes, splicedNodes: splicedNodes, nodeLabel: nodeLabel, pinnedIndex: pinnedIndex});
            // console.log(pinnedNodes);
            filter_statements(pinnedNodes, 'community');



            if (commClicked.indexOf(communityClicked) == -1) {
                // console.log("the community clicked was not clicked before");


                // sigma.instances(0).graph.edges().forEach(function(e) {
                //
                //     if (e.statement_id == keepStatementID) {
                //         e.color = e.originalColor;
                //     }
                //     else {
                //         e.color = '#ddd';
                //     }
                //
                // });

                // Specify which community is clicked
                commClicked.push(communityClicked);


                // Make only those nodes visible that belong to the community selected

                sigma.instances(0).graph.nodes().forEach(function(n) {

                    if (commClicked.indexOf(n.community.toString()) > -1)  {
                        n.color = n.originalColor;
                        n.label = n.originalLabel;
                        if (n.originalLabel == nodeLabel && pinnedNodes.indexOf(n.originalLabel) > -1) {
                          n.color = '#0089e0';
                        }
                    }
                    else {
                      n.color = deselected_nodes_color;
                      n.label = '';
                    }

                });
            }

            else {
              // console.log("the community was clicked before");

                if (pinnedNodes.length == 0) {
                    // sigma.instances(0).graph.edges().forEach(function(e) {
                    //     e.color = e.originalColor;
                    // });

                    commClicked.splice(commClicked.indexOf(communityClicked.toString()),1);

                    // Make only those nodes visible that belong to the statement selected
                    sigma.instances(0).graph.nodes().forEach(function(n) {
                      if (commClicked.indexOf(n.community.toString()) < 0) {
                              if (commClicked.length == 0) {
                                n.color = n.originalColor;
                                n.label = n.originalLabel;
                              }
                              else {
                                n.color = deselected_nodes_color;
                                n.label = '';
                              }
                      }
                    });


                  }
                else {
                    // We clicked on the community which is in the DB of clicked ones and We have some pinned nodes left

                      // Is the node clicked in the pinned nodes?
                      if (pinnedNodes.indexOf(nodeLabel) > -1) {
                        // console.log('in the pinned nodes')
                        sigma.instances(0).graph.nodes().forEach(function(n) {
                          if (commClicked.indexOf(n.community.toString()) > -1)  {
                              n.color = n.originalColor;
                              n.label = n.originalLabel;
                              if (n.originalLabel == nodeLabel && pinnedNodes.indexOf(n.originalLabel) > -1) {
                                n.color = '#0089e0';
                              }
                          }
                          else {
                            n.color = deselected_nodes_color;
                            n.label = '';
                          }
                      });
                    }
                    // It is not in the pinneed nodes
                    else {
                      // console.log('not in the pinneed nodes')
                      // console.log(commClicked)
                      // console.log(pinnedNodes);

                      // is the last node of the community?
                      var islastnode = 0;
                      for (key in topp_communities) {
                        if (communityClicked == topp_communities[key].id) {
                          for (kkey in topp_communities[key].nodes) {
                            // console.log(topp_communities[key].nodes[kkey].name);
                            // console.log(pinnedNodes.indexOf(topp_communities[key].nodes[kkey].name));
                            if (pinnedNodes.indexOf(topp_communities[key].nodes[kkey].name) > -1) {
                              islastnode = 1;
                            }

                          }
                        }
                      }
                      // console.log(islastnode);

                      if (!islastnode) {
                        commClicked.splice(commClicked.indexOf(communityClicked.toString()),1);
                      }
                      //console.log(pinnedNodes);

                      sigma.instances(0).graph.nodes().forEach(function(n) {
                        if (commClicked.indexOf(n.community.toString()) < 0) {
                                if (commClicked.length == 0) {
                                  n.color = n.originalColor;
                                  n.label = n.originalLabel;
                                }
                                else {
                                  n.color = deselected_nodes_color;
                                  n.label = '';
                                }

                        }

                        if (pinnedNodes.indexOf(n.originalLabel) > -1) {
                          n.color = '#0089e0';
                          n.label = n.originalLabel;
                        }
                        if (pinnedNodes.indexOf(n.originalLabel) < 0 && islastnode && n.originalLabel == nodeLabel) {
                          n.color = n.originalColor;
                          n.label = n.originalLabel;
                        }


                      });

                    }
                }

            }

            sigma.instances(0).refresh();

      });

    }


    $("#summary").click(function(e) {
        e.preventDefault();

        // // Top influence nodes
      //   console.log(toppbc_nodes);
        //
        // // Top community nodes
        // console.log(topp_communities);

        filter_statements_summary(most_inf_nodes, most_inf_comm_nodes);

        $('#topnav_items').each(function() {
            $("li", this).each(function(i) {
                $(this).removeClass('pure-menu-selected-top');
            });
        });
        this.className = 'pure-menu-selected-top';
        // Top community terms

    });

    $("#insight").click(function(e) {
        e.preventDefault();

        var insight_nodes = [];

        if (polysingularity_score == 'Diversified') {
          if (most_inf_comm_nodes[0]) {
            insight_nodes.push(most_inf_comm_nodes[0]);
          }
          if (most_inf_comm_nodes[1]) {
            insight_nodes.push(most_inf_comm_nodes[1]);
          }
        }
        else {
          if (most_inf_comm_nodes[most_inf_comm_nodes.length-1]) {
            insight_nodes.push(most_inf_comm_nodes[most_inf_comm_nodes.length-1]);
          }
          if (most_inf_comm_nodes[most_inf_comm_nodes.length-2]) {
            insight_nodes.push(most_inf_comm_nodes[most_inf_comm_nodes.length-2]);
          }
        }


        filter_statements_summary(most_inf_nodes, insight_nodes, 'insight');

        $('#topnav_items').each(function() {
            $("li", this).each(function(i) {
                $(this).removeClass('pure-menu-selected-top');
            });
        });
        this.className = 'pure-menu-selected-top';
        // Top community terms

    });

    $("#overview").click(function(e) {
        e.preventDefault();
        $('.entry').fadeIn(400);
        $('#topnav_items').each(function() {
            $("li", this).each(function(i) {
                $(this).removeClass('pure-menu-selected-top');
            });
        });
        this.className = 'pure-menu-selected-top';
        $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);

        if (pinnedNodes.length > 0) {
          filter_statements(pinnedNodes);
        }
        filter_graph(pinnedNodes);
        $('.summary').remove();
        $('#explanation').hide();
    });

    // Filter out the statements that don't have any of the nodes clicked

    var timesfiltered = 0;

    function filter_statements(pinnedNodes, origin) {


        var showingsomething = 0;

        var visibleentries = visibleentries_original;

        // Hide the sentences that don't contain the terms

        if (origin != 'stopwords') {

        // TODO redo this because to do so much for every statement is crazy PRIORITY

        $(".entry").each(function(){

            var currentDiv = $(this).attr('data-uid');

            // Retrieve the statement text from the entry, clean from html
            var originaltext = $(this).children('.entry-text').html();

            // Make an array from sentences of that text
            var sentences = originaltext.split(/[.|!|?]\s/gi);

            var searchlemmas = [];


            // START Check what sentences contain the node clicked

            var startmark = sentences.length; // How many sentences are inside

            for (var i = 0; i < sentences.length; i++) {

                // What language is the sentence?
                var sentence_cyrillic = sentences[i].match(/[--]/);

                var nodesfound = 0;

                // Transform the sentence into a series of morphemes
                var sentences_lemmas = sentences[i].split(' ');

                // SEARCH MOD
                /*for (var z = 0; z < sentences_lemmas.length; z++) {
                    sentences_lemmas[z] = window.jstemmer(sentences_lemmas[z]);
                }
*/

                var sentences_lemmas_string = sentences_lemmas.join(' ');

                // Check how many of the nodes are found in This 1 Sentence i

                for (var j = 0; j < pinnedNodes.length; j++) {

                    // Is the search term cyrillic?
                    var search_cyrillic = pinnedNodes[j].match(/[--]/);

                    // SEARCHMOD
                    // var search_lemma = window.jstemmer(pinnedNodes[j]);

                    var search_lemma = pinnedNodes[j];

                    searchlemmas.push(search_lemma);

                    if (sentences_lemmas_string.toLowerCase().indexOf(search_lemma.toLowerCase()) > -1) {
                        nodesfound = nodesfound + 1;
                    }
                    else if (sentence_cyrillic != null && search_cyrillic != null)  {
                        if (sentences_lemmas_string.toLowerCase().indexOf(search_lemma.toLowerCase().slice(0,-1)) > -1) {
                            nodesfound = nodesfound + 1;
                        }
                    }

                }

                // At least one node not found? Mark it as non matched

                if (nodesfound >= pinnedNodes.length) {
                    sentences[i] = sentences[i] + '.';
                }
                else {
                    sentences[i] = '<div class="nonmatched-sentence">' + sentences[i] + '.</div>';
                    startmark = startmark - 1;
                }


            }

            // Make a new text from the filtered sentences
            var newtext = '';

            if (startmark == sentences.length) {
                newtext = originaltext;
                // $(this).find('.entry-menu').fadeOut(500);
                showingsomething = showingsomething + 1;
            }

            else {
                newtext = originaltext; // sentences.join(' '); if we want to hide non-matched sentences
                // $(this).find('.entry-menu').fadeIn(500);
                if (startmark != 0) {
                    showingsomething = showingsomething + 1;
                }
            }

            if (startmark == 0) {

                $(this).fadeOut(500);

                visibleentries = visibleentries - 1;

                // This will get activated only if the iterative search didn't give any results

                if (visibleentries == 0 && showingsomething == 0) {

                    $('.entry').fadeIn(500);

                    timesfiltered = timesfiltered + 1;

                    // This is if we want to remove the node before the last one.
                    // var posnodes = pinnedNodes.length - timesfiltered - 1;

                    var posnodes = 0;
                    var lastnode = pinnedNodes.length - 1;

                    // Final nodes to search

                    splicedNodes = [];


                    // First all of them

                    for (var k = 0; k < pinnedNodes.length; k++) {
                        splicedNodes[k] = pinnedNodes[k];
                    }

                    // Remove the one we can't find (the very first one of the bunch)

                    splicedNodes.splice(posnodes, 1);

                    // Save that one also into the list of the nodes we removed

                    notfoundNodes.push(pinnedNodes[posnodes]);

                    // This is for alert
                    // var r = confirm('No link between ' + pinnedNodes + '.\nShow entries just with ' + splicedNodes + '?');

                    // This is for plain message
                    // $('#messages').html('No entries contain "' + pinnedNodes.join(' and ') + '".<br>Showing entries that contain "' + splicedNodes.join(' and ') + '" only:<br>&nbsp;');

                    // Get the pinnedNodes back to a good shape
                    pinnedNodes = [];
                    for (var l = 0; l < splicedNodes.length; l++) {
                        pinnedNodes[l] = splicedNodes[l];
                    }

                    // Relaunch the function with the newly cleared list of pinnedNodes

                    filter_statements(pinnedNodes, origin);

                }
            // END OF not found any entries with the nodes clicked
            }

            // FOUND something with the nodes clicked
            else {

                // Populate statement with a new text

                $(this).children('.entry-text').html(newtext);

                // $(this).find('.nonmatched-sentence').fadeOut(500); this is only if we want to fade non-matched sentences - see above also



            }


        });



                        if (pinnedNodes.length > 0) {
                                if (background == 'dark') {
                                  $('#deletenodes').addClass('deletenodes-dark');
                                  $('#undo').addClass('undo-dark');
                                }
                                else {
                                  $('#deletenodes').addClass('deletenodes-on');
                                  $('#undo').addClass('undo-on');
                                }

                        }
                        else {
                          if (background == 'dark') {
                            $('#deletenodes').removeClass('deletenodes-dark');
                            $('#undo').removeClass('undo-dark');
                          }
                          else {
                            $('#deletenodes').removeClass('deletenodes-on');
                            $('#undo').removeClass('undo-on');
                          }

                        }

                        // Show tags that are currently used in search

                        var htmlNodes =  '<ul class="tags">';
                        var pinnedNodes_string = '';

                        if (pinnedNodes.length == 0) { notfoundNodes = [] }

                        for (var x = 0; x < notfoundNodes.length; x++) {
                            htmlNodes = htmlNodes + '<li><a class="notfound" href="#">' + notfoundNodes[x] + '</a></li>';
                            pinnedNodes_string = pinnedNodes_string + '#' + notfoundNodes[x] + ' ';
                        }

                        for (var q = 0; q < pinnedNodes.length; q++) {
                            htmlNodes = htmlNodes + '<li><a href="#">' + pinnedNodes[q] + '</a></li>';
                            pinnedNodes_string = pinnedNodes_string + '#' + pinnedNodes[q] + ' ';
                        }

                        if ($('#addnodeinput').val().length == 0 || $('#addnodeinput').val().charAt(0) == '#') {
                          $('#addnodeinput').val(pinnedNodes_string);
                        }

                        if ($('#statement').val().length == 0 || $('#statement').val().charAt(0) == '#') {
                          $('#statement').val(pinnedNodes_string);
                        }


                        htmlNodes = htmlNodes + '<div class="tagsend"></div></ul>';

                      //  notfoundNodes = [];

                        $('#pinnednodeslist').html(htmlNodes);


        // Highlight the nodes that were clicked

        $(".entry").removeHighlight();

        for (var i=0; i<pinnedNodes.length; i++) {
            $(".entry").highlight(pinnedNodes[i]);

        }

        // Show only the clicked nodes and their neighbors in the graph
        if (origin != 'community' && origin != 'stopwords') {
          filter_graph(pinnedNodes, origin);
        }


        // END OF if origin != stopwords
      }

       // If we're coming from stopwords, adjust deletedNodes
        if (origin == 'stopwords') {
                deletedNodes = pinnedNodes;
                  if ($('#summary').hasClass('pure-menu-selected-top')) {
                      $('#summary').click();
                  }
                  if ($('#insight').hasClass('pure-menu-selected-top')) {
                      $('#insight').click();
                  }
        }

        // Then generate the interface
        var stopNodesList = '<ul class="tags">';
        for (var x = 0; x < deletedNodes.length; x++) {
            stopNodesList = stopNodesList + '<li><a class="deleted" href="#">' + deletedNodes[x] + '</a></li>';
        }
        stopNodesList = stopNodesList + '</ul>';


        // Save all this data in localStorage

        if (localStorage.getItem("selections")) {
            var localstore = JSON.parse(localStorage.getItem("selections"));
        }
        else {
            var localstore = {};
        }

        var localstore_cell = {};

        localstore_cell.stopnodes = deletedNodes;
        localstore_cell.pinnednodes = pinnedNodes;

        if (deletedNodes.length == 0 && pinnedNodes.length == 0) {
          delete localstore[window.location.href]
        }
        else {
          localstore[window.location.href] = localstore_cell;
        }

        localStorage.setItem("selections",JSON.stringify(localstore));

        if (deletedNodes.length > 0) {
          if (background == 'dark') {
            $('#stopsave').addClass('stopsave-dark');

          }
          else {
            $('#stopsave').addClass('stopsave-on');

          }
        }
        else {
          if (background == 'dark') {
            $('#stopsave').removeClass('stopsave-dark');

          }
          else {
            $('#stopsave').removeClass('stopsave-on');

          }

        }

        $('#stopnodeslist').html(stopNodesList);

        // Add triggers to newly shown Tags elements

        addTagTriggers();


        if (pinnedNodes.length == 0) {
            if (addcontext && interpret) {


              $('.entry').hide();

              for (var ite in statementsOfContext[current_context]) {

                $('.entry[data-uid="' + statementsOfContext[current_context][ite] + '"]').each(function() {
                  $(this).show();
                });

              }

          }
        }

        if ($('#summary').hasClass('pure-menu-selected-top')) {
          if (pinnedNodes.length == 0) {
            $('#summary').click();
          }
        }
        if ($('#insight').hasClass('pure-menu-selected-top')) {
          if (pinnedNodes.length == 0) {
            $('#insight').click();
          }
        }

    }

    function addContextTriggers() {

    // TODO Add case for clicking viewAll, so it doesn't reload the page, but simply removes all filters

    // Find @Contexts and make them filter statements when clicked

        var contextsToFilter = [];


        $(".app-context-link").click(function(e) {
            e.preventDefault();
            var that = this;
            setTimeout(function() {
                var dblclick = parseInt($(that).data('double'), 10);
                if (dblclick > 0) {
                    $(that).data('double', dblclick-1);
                } else {
                    if (e.shiftKey || ($(".addcontext-on").is(":visible"))) {
                      shiftClick.call(that, e);
                    }
                    else {
                      singleClick.call(that, e);
                    }
                }
            }, 300);
        }).dblclick(function(e) {
                    $(this).data('double', 2);
                    doubleClick.call(this, e);
                });


        // If double click on the menu, open it

        function singleClick (e) {

            window.location = e.target.href;

        }

        // If shift click on the menu, open comparison with other context

        function shiftClick (e) {

            window.location = e.target.href + '?addcontext=' + current_context;

        }

        // If double click on a link, open it

        $(".app-url-link").on('click tap', function(e) {

              e.stopPropagation();

        });



        // If only one click, filter it

        function doubleClick (e) {

                var triggeredFromStatement = null;

                var addFilter = null;

                var removeFilter = null;

                // Extract filter label
                var filter = $(e.target).text();

                // Remove the first @ in case it's @mentions clicked from the statements
                if (filter.charAt(0) == '@') {
                    filter = filter.substr(1);
                    triggeredFromStatement = 1;
                }

                // Some tricks to make context switch from statements emulate menu items behavior
                if (triggeredFromStatement) {

                    // If the context is clicked inside the statement, we're just dealing with that event, not others
                    e.stopPropagation();

                    $(".menu-item-divided").each(function() {
                         if (S($(this).html()).stripTags().s == filter) {
                             if ($(this).hasClass('pure-menu-selected')) {
                                 $(this).removeClass('pure-menu-selected');
                                 removeFilter = 1;
                             }
                             else {
                                 $(this).addClass('pure-menu-selected');
                                 addFilter = 1;
                             }
                         }

                    });
                }

                // Index of that filter in our current contextsToFilter array
                var filterIndex = contextsToFilter.indexOf(filter);

                // Toggle menu highlights
                if ($(this).hasClass('pure-menu-selected') || removeFilter) {


                    // The context is to be removed
                    if (!removeFilter) {
                        $(this).removeClass('pure-menu-selected');
                    }

                    // Does it exist in the list of contexts to filter?
                    if (filterIndex > -1) {
                        contextsToFilter.splice(filterIndex, 1);
                    }

                    //TODO WTF is that?
                  /*  // Let's remove the nodes that belong to the removed context from the contextNodes
                    contextNodeID[to_remove_clean].forEach(function(element){
                        var index = $.inArray(element, contextNodes);
                        if (index>=0) contextNodes.splice(index, 1);
                    });*/


                     // Create context query for jQuery
                    var contextstring = '';

                    if (contextsToFilter.length >= 0) {
                        contextstring += ".entry:contains('@"+contextsToFilter[0]+"')";

                        for (var l=1;l<contextsToFilter.length;++l) {
                            contextstring += ", .entry:contains('@"+contextsToFilter[l]+"')";
                        }

                        $('.entry').addClass('hidden');
                        $(contextstring).removeClass('hidden');

                    }
                    else {
                        $('.entry').removeClass('hidden');
                    }


                    if (contextsToFilter.length < 1 && !$('#listall').hasClass('pure-menu-selected') && !(current_context)) {
                        $('#listall').addClass('pure-menu-selected');
                    }

                }
                else {
                    if (!addFilter) {
                        $(this).addClass('pure-menu-selected');
                    }

                    // Add this context to a list of contextToFilter
                    if (filterIndex < 0) {
                        contextsToFilter.push(filter);
                    }

                    // Show only those that have the context

                    var contextstring = '';
                    if (contextsToFilter.length >= 0) {
                        contextstring += ".entry:contains('@"+contextsToFilter[0]+"')";

                        for (var l=1;l<contextsToFilter.length;++l) {
                            contextstring += ", .entry:contains('@"+contextsToFilter[l]+"')";
                        }

                        $('.entry').addClass('hidden');
                        $(contextstring).removeClass('hidden');

                    }
                    else {
                        $('.entry').removeClass('hidden');
                    }


                    if ($('#listall').hasClass('pure-menu-selected')) {
                        $('#listall').removeClass('pure-menu-selected');
                    }


                }

                console.log(contextsToFilter);

                // Add contexts into the submission form
                document.getElementById('selectedContexts').value = contextsToFilter.join(',');

                console.log(document.getElementById('selectedContexts').value);

                // Add some remove @context functionality
                renderGraph(contextsToFilter);

         }

    }





    // Remove context filters function - launched only when a context is clicked

    function renderGraph(contextsToFilter) {

        // Creating the context index
        var nodesToKeep = [];

        var keepNodes = [];

        var keepEdges = [];

        // First, let's reiterate the graph and make a list of nodes and edges to keep

        if (contextsToFilter.length > 0) {

            sigma.instances(0).graph.edges().forEach(function(e) {

                // Reiterating through edges, leaving only the nodes that appear in at least one filtered context

                contextsToFilter.forEach(function(element){

                    if (contextNodeID[element].indexOf(e.source) > -1) {
                        keepNodes.push(e.source);
                    }

                    if (contextNodeID[element].indexOf(e.target) > -1) {
                        keepNodes.push(e.target);
                    }

                });

                // Keep edges that are in at least one of the filtered contexts

                if (contextsToFilter.indexOf(e.edge_context) > -1) {
                    keepEdges.push(e.id);
                }


            });
        }

        // Uniqualize to avoid duplicates

        keepNodes = $.unique(keepNodes);
        keepEdges = $.unique(keepEdges);


        // Then let's reiterate the graph edges and only show nodes that belong to the contexts created

        sigma.instances(0).graph.edges().forEach(function(e) {

            if (contextsToFilter.length == 0) {
                // Show the edge if there's no contexts at all
                e.color = e.originalColor;
            }

            else if (keepEdges.indexOf(e.id) > -1) {
                // The edge is in the list to keep => show it normal color
                e.color = e.originalColor;

                // The source of the edge is in the list to keep, so we will keep it.
                if (keepNodes.indexOf(e.source) > -1) {
                    nodesToKeep.push(e.source);
                }
                // The target of the edge is in the list to keep, so we will keep it also.
                if (keepNodes.indexOf(e.target) > -1) {
                    nodesToKeep.push(e.target);
                }
                // PS We only do this check for the nodes that belong to the edges that we keep
            }
            else {
                // Otherwise (the edge IS in the list for removal), so we color the edge invisible
                e.color = deselected_nodes_color;
            }



        });



        // Ensure no duplicates
        nodesToKeep = $.unique(nodesToKeep);

        // Now that we know which nodes to keep, let's reiterate through them all

        sigma.instances(0).graph.nodes().forEach(function(n) {

            // Is there no contexts at all? Show the node.
            if (contextsToFilter.length == 0) {
                n.color = n.originalColor;
                n.label = n.originalLabel;
            }

            // The node is not in the list to keep? Hide it!
            else if (nodesToKeep.indexOf(n.id) < 0)  {
                n.color = deselected_nodes_color;
                n.label = '';
            }

            // Looks like there is a filtering context function AND the node is in the keep list, so make it show!
            else {
                n.color = n.originalColor;
                n.label = n.originalLabel;
            }
        });


        // Refresh the graph (we do it through instances(0) as we're a bit outside of Sigma now)
        sigma.instances(0).refresh();


    }


    // Populate context menu

    function populateContextMenu (contextNames) {

        var switch_field = '';

        var context_filters = '';

        var currentContextURL = '';

        var appshome = '';

        var settingspane = '';
        <% if (perceivername) { %>

            currentContextURL = '<li id="listall" class="menu-item-divided pure-menu-selected"><a href="/<%= perceivername %>">all contexts</a></li>';

        <% } else { %>

            currentContextURL = '<li id="listall" class="menu-item-divided pure-menu-selected"><a href="/<%= user.name %>/edit">all contexts</a></li>';

        <% } %>

        var addNewContext = '';

        var auxLinks = '';

        var detectedContext = null;

        // The graph exists already?
        if (typeof contextNames[0] !== 'undefined' && contextNames[0] !== null) {
            contextNames.forEach(function(n) {
                if (n == current_context) {
                    detectedContext = 1;
                    // for the menu
                    <% if (perceivername) { %>
                        context_filters += '<li class="app-context-link menu-item-divided pure-menu-selected"><a href="/<%= perceivername %>/' + n + '">' + n + '</a></li>';
                        currentContextURL = '<li id="listall" class="menu-item-divided"><a href="/<%= perceivername %>">all contexts</a></li>';
                    <% } else { %>
                        context_filters += '<li class="app-context-link menu-item-divided pure-menu-selected"><a href="/<%= user.name %>/' + n + '/edit">' + n + '</a></li>';
                        currentContextURL = '<li id="listall" class="menu-item-divided"><a href="/<%= user.name %>/edit">all contexts</a></li>';
                    <% } %>
                }
                else {
                    // for the menu
                    <% if (perceivername) { %>
                        context_filters += '<li class="app-context-link menu-item-divided "><a href="/<%= perceivername %>/' + n + '">' + n + '</a></li>';
                    <% } else { %>
                        context_filters += '<li class="app-context-link menu-item-divided "><a href="/<%= user.name %>/' + n + '/edit">' + n + '</a></li>';

                    <% } %>

                    // for the statement add
                }
            });
            // TODO this is code repeat from above, optimize
            if (!detectedContext && current_context) {
              <% if (perceivername) { %>
                  context_filters = '<li class="app-context-link menu-item-divided pure-menu-selected"><a href="/<%= perceivername %>/' + current_context + '">' + current_context + '</a></li>' + context_filters;
                  currentContextURL = '<li id="listall" class="menu-item-divided"><a href="/<%= perceivername %>">all contexts</a></li>';
              <% } else { %>
                  context_filters = '<li class="app-context-link menu-item-divided pure-menu-selected"><a href="/<%= user.name %>/' + current_context + '/edit">' + current_context + '</a></li>' + context_filters;
                  currentContextURL = '<li id="listall" class="menu-item-divided"><a href="/<%= user.name %>/edit">all contexts</a></li>';
              <% } %>
            }
        }
        // No graph, so show private
        else {
            context_filters += '<li class="app-context-link menu-item-divided"><a href="/<%= perceivername %>/private/edit">private</a></li>';
        }

        <% if (!perceivername) { %>
            addNewContext = '<li id="addNewContext" class="menu-item-divided"><a id="addcontextbutton" href="javascript:"> + new context&nbsp;&nbsp;</a>&nbsp;<form action="/post" method="GET" class="pure-form" id="addcontextinput"><input type="text" id="addcontextname" size="7" class="pure-input"></form></li>';
        <% } else { %>
            addNewContext = '<li class="menu-item-divided">&nbsp;<a href="javascript:"></a></li>';

        <% } %>


        // We are viewing the user's public page?

        <% if ((perceivername)) { %>

            // So we know whose statements we see, but is it the same as the user who's viewing them?
            <% if (perceivername == receivername) { %>

            <% if (context) { %>
                // switch_field = '<li class="menu-item-small"><a href="/<%= perceivername %>/<%= context %>/edit">go to private view</a></li>';
            <% } else { %>
                // switch_field = '<li class="menu-item-small"><a href="/<%= perceivername %>/edit">go to private view</a></li>';
            <% } %>

            // So we know whose statements we're going to view, but the user is not the same as the one who made them.
            <% } else { %>



            <% } %>

        // We are viewing the user's private page

        <% } else {  %>

        <% if (context) { %>

                switch_field = '<li class="menu-item-small">&nbsp;</li><li class="menu-item-small"><a href="/<%= user.name %>/<% context %>">go to public view</a></li>';

            <% } else { %>

                switch_field = '<li class="menu-item-small">&nbsp;</li><li class="menu-item-small"><a href="/<%= user.name %>">go to public view</a></li>';

            <% } %>


        <% } %>


        <% if (perceivername) { %>

            <% if (perceivername == receivername) { %>
                settingspane = '<li class="menu-item-small" id="settingspane"><a href="/settings">settings</a></li><br>';
                appshome = '<li class="menu-item-small"><a href="/apps">apps/home</a></li>';
                auxLinks = '<br>' +
                        '<li class="menu-item-small"><a href="/<%= perceivername %>/edit">back to private view</a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-divided"><a href="/logout">logout</a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-divided"><a href="/import">import</a></li>' +
                        '<li class="menu-item-divided"><a href="/api/public/nodes/<%= perceivername %>/<%= context %>" target="_blank">export</a></li>' +
                        '<li class="menu-item-small"><a href="/api/public/nodes/<%= perceivername %>/<%= context %>?gexf=1" target="_blank" download="<%= perceivername %>_<%= context %>.gexf">gexf</a> <a href="/api/public/nodes/<%= perceivername %>/<%= context %>?csv=1" target="_blank" download="<%= perceivername %>_<%= context %>.csv">csv</a> <a href="/api/public/nodes/<%= perceivername %>/<%= context %>?csvdata=1" target="_blank">csv matrix</a>  <a href="/api/user/statements/<%= context %>?textonly=1" target="_blank">text only</a> <a href="" target="_blank" id="downloadpng">PNG image</a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-small"><a href="http://noduslabs.com/infranodus/" target="_blank">about</a></li>' +
                        '<li class="menu-item-small"><a href="http://noduslabs.com/contact/" target="_blank">contact</a></li>' +
                        '<li class="menu-item-small"><a href="http://github.com/noduslabs/infranodus" target="_blank">help &amp; github</a></li>';


            <% } else if (receivername) { %>
                settingspane = '<li class="menu-item-small" id="settingspane"><a href="/settings">settings</a></li><br>';
                appshome = '<li class="menu-item-small"><a href="/apps">apps/home</a></li>';
                auxLinks = '<br>' +
                        '<li class="menu-item-small"><a href="/<%= receivername %>/edit">back to <%= receivername %></a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-divided"><a href="/">home page</a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-divided"><a href="/import">import</a></li>' +
                        '<li class="menu-item-divided"><a href="/api/user/nodes/<%= context %>" target="_blank">export</a></li>' +
                        '<li class="menu-item-small"><a href="/api/user/nodes/<%= context %>?gexf=1" target="_blank" download="<%= context %>.gexf">gexf</a> <a href="/api/user/nodes/<%= context %>?csv=1" target="_blank">csv</a> <a href="/api/user/nodes/<%= context %>?csvdata=1" target="_blank">csv matrix</a> <a href="" target="_blank" id="downloadpng">PNG image</a></li>' +
                        '<li class="menu-item-small"><a href="http://noduslabs.com/infranodus/" target="_blank">about</a></li>' +
                        '<li class="menu-item-small"><a href="http://noduslabs.com/contact/" target="_blank">contact</a></li>' +
                        '<li class="menu-item-small"><a href="http://github.com/noduslabs/infranodus" target="_blank">help &amp; github</a></li>';


            <% } else { %>
              appshome = '<li class="menu-item-small"><a href="/">infranodus.com</a></li>';
                auxLinks = '<br>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-divided"><a href="/login">login</a></li>' +
                        '<li class="menu-item-divided"><a href="/signup">signup</a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-divided"><a href="/api/public/nodes/<%= perceivername %>/<%= context %>" target="_blank">export</a></li>' +
                        '<li class="menu-item-small"><a href="/api/public/nodes/<%= perceivername %>/<%= context %>?gexf=1" target="_blank" download="<%= context %>.gexf">gexf</a> <a href="/api/public/nodes/<%= perceivername %>/<%= context %>?csv=1" target="_blank">csv</a> <a href="/api/public/nodes/<%= perceivername %>/<%= context %>?csvdata=1" target="_blank">csv matrix</a> <a href="" target="_blank" id="downloadpng">PNG image</a></li> ' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-divided"><a href="/#tutorials" target="_blank">tutorials</a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-small"><a href="http://noduslabs.com/infranodus/" target="_blank">about</a></li>' +
                        '<li class="menu-item-small"><a href="/#features">demo</a></li>' +
                        '<li class="menu-item-small"><a href="/#usecases">case studies</a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-small"><a href="http://noduslabs.com/contact/" target="_blank">contact</a></li>' +
                        '<li class="menu-item-small"><a href="http://github.com/noduslabs/infranodus" target="_blank">help &amp; github</a></li>';

            <% } %>

        <% } else { %>
            settingspane = '<li class="menu-item-small" id="settingspane"><a href="/settings">settings</a></li><br>';
            appshome = '<li class="menu-item-small"><a href="/">infranodus.com</a></li><li class="menu-item-small"><a href="/apps">apps/home</a></li>';
            auxLinks = '<br>' +
                    '<li class="menu-item-divided"><a href="/logout">logout</a></li>' +
                    '<li class="menu-item-small">&nbsp;</li>' +
                    '<li class="menu-item-divided"><a href="/import">import</a></li>' +
                    '<li class="menu-item-divided"><a href="/api/user/nodes/<%= context %>" target="_blank">export</a></li>' +
                    '<li class="menu-item-small"><a href="/api/user/nodes/<%= context %>?gexf=1" target="_blank" download="<%= context %>.gexf">gexf</a> <a href="/api/user/nodes/<%= context %>?csv=1" target="_blank">csv</a> <a href="/api/user/nodes/<%= context %>?csvdata=1" target="_blank">csv matrix</a>  <a href="/api/user/statements/<%= context %>?textonly=1" target="_blank">text only</a> <a href="" target="_blank" id="downloadpng">PNG image</a></li>' +
                    '<li class="menu-item-small">&nbsp;</li>' +
                    '<li class="menu-item-small"><a href="/#tutorials" target="_blank">video tutorials</a></li>' +
                    '<li class="menu-item-small"><a href="http://noduslabs.com/courses/text-network-analysis-for-cognitive-stimulation/" target="_blank">online course</a></li>' +
                    '<li class="menu-item-small"><a href="http://noduslabs.com/category/tutorials/" target="_blank">case studies</a></li>' +
                    '<li class="menu-item-small">&nbsp;</li>' +
                    '<li class="menu-item-small"><a href="http://noduslabs.com/contact/" target="_blank">contact</a></li>' +
                    '<li class="menu-item-small"><a href="http://github.com/noduslabs/infranodus" target="_blank">help &amp; github</a></li>';

        <% } %>

        document.getElementById('contexts').innerHTML = appshome +
                                                        settingspane +
                                                        addNewContext +
                                                        currentContextURL +
                                                        context_filters +
                                                        switch_field +
                                                        auxLinks;



        // Select range in textarea function

        $.fn.selectRange = function(start, end) {
            return this.each(function() {
                if (this.setSelectionRange) {
                    this.focus();
                    this.setSelectionRange(start, end);
                } else if (this.createTextRange) {
                    var range = this.createTextRange();
                    range.collapse(true);
                    range.moveEnd('character', end);
                    range.moveStart('character', start);
                    range.select();
                }
            });
        };

        // When add new context is clicked, add it into textarea and select it

        $("#addNewContext").on('tap', function(e) {

            $("#addcontextinput").css("visibility", "visible");
            $("#add").css("visibility", "visible");
            $("#addcontextname").focus();


        });

        <% if (!perceivername) { %>
        $('#addcontextinput').submit(function(e) {
            e.preventDefault(); // to stop the form from submitting
            if ($('#addcontextname').val().length > 0) {
                var contextredirect = $('#addcontextname').val();
                contextredirect = contextredirect.replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()]/g,"");
                contextredirect = contextredirect.replace(/[^\w]/gi, '');
                window.location.href = "/<%= user.name %>/" + contextredirect + '/edit';
            }

        });
        <% } %>

        // Now time to trigger the actions we want to have when user clicks on the contexts
        addContextTriggers();



        if (newcontextname) {
          // $('#menuLink').click();
          $("#addcontextinput").css("visibility", "visible");
          $("#addcontextname").focus();
          $("#addcontextname").val(newcontextname);
        }


    }

    function search_graph() {

        // Autocomplete for search input
        $("#search").autocomplete({
            source: nodeNames,
            minLength: 1,
            delay: 500,
            messages: {
                noResults: '',
                results: function() {}
            },
            select: function(event, ui) {

                var filter = ui.item.value;



            }

        });


        $("#searchform").submit(function(event) {

            event.preventDefault();

            // What are we searching?
            var searchPhrase = $('#search').val();

            if (searchPhrase.length > 1) {

                // Clean up the search string
                searchPhrase = searchPhrase.replace(/\s+/g,' ').trim();

                // Separate terms into array
                var searchArray = searchPhrase.toLowerCase().split(" ");

                var searchPhraseLemmas = [];


                for (var j = 0; j < searchArray.length; j++) {

                    // Is the search term cyrillic?
                    var search_cyrillic = searchArray[j].match(/[--]/);

                    // SEARCHMOD
                    // var search_lemma = window.jstemmer(searchArray[j]);

                    var search_lemma = searchArray[j];

                    searchPhraseLemmas.push(search_lemma);

                }

                for (var k = 0; k < searchPhraseLemmas.length; k++) {
                    if (pinnedNodes.indexOf(searchPhraseLemmas[k]) < 0) {
                        pinnedNodes.push(searchPhraseLemmas[k]);
                    }
                }

                filter_statements(pinnedNodes, "search");

            }


        });
    }


    function filter_graph(pins, origin){


            var toKeep = [];

            var toKeepMap = [];


            // Debug: show which nodes are clicked

            //console.log(pins);

            // Are any nodes at all selected on the graph?

            if (pins.length > 0) {


                // Reiterate for each pinned node

                for (var i = 0; i < pins.length; i ++) {

                    // Now we reiterate through every node in the graph

                    sigma.instances(0).graph.nodes().filter(function(n) {

                        var pinSearch = '';

                        // Lemmataze search query if we're coming from search box

                        // SEARCHMOD
                       /* if (origin == 'search') {

                            var nodeLemma = window.jstemmer(n.originalLabel);


                            if (nodeLemma.length > 0) {
                                pinSearch = nodeLemma;
                            }
                            else {
                                pinSearch = n.originalLabel;
                            }
                        }

                        // This means the user clicked on the tag or on the graph, so we use that exact parameter to search

                        else {
                            pinSearch = n.originalLabel;
                        }*/

                        pinSearch = n.originalLabel;

                        // Is the current node of the graph one of the ones that was clicked before?

                        if (pins[i] == pinSearch) {



                            // The ID of the current node is...
                            var nodeId = n.id;

                            // Its neighbors are...
                            var nnodes = sigma.instances(0).graph.neighbors(nodeId);

                            var nnodesArray = []

                            // We create an array from neighbors that looks like toKeep one

                            for (key in nnodes) {
                                nnodesArray.push(nnodes[key]);
                            }

                            // If that's not the first iteration, we only keep intersection of both

                            if (i > 0) {
                                toKeep = _.intersection(toKeep, nnodesArray);
                            }
                            else {
                                toKeep = nnodesArray;
                            }

                            // add the node itself to keep
                            toKeep.push(n);



                        }

                    });

                }

                // Make array of nodes to keep unique to avoid duplicates

                toKeep = _.uniq(toKeep);

                console.log(toKeep);

                selectedNodes = [];
                for (var irr in toKeep) {
                  selectedNodes.push(toKeep[irr].label);
                }


                // Now convert this to an array that will be understood by the functions below

                for (key in toKeep) {
                    toKeepMap[toKeep[key].id] = toKeep[key];
                }


                // For each node in the graph

                sigma.instances(0).graph.nodes().forEach(function(n) {

                    if (toKeepMap[n.id])  {

                        var pinSearch = '';

                        // Lemmataze search query if we're coming from search box
                        // SEARCHMOD
                       /* if (origin == 'search') {
                            var nodeLemma = window.jstemmer(n.originalLabel);


                            if (nodeLemma.length > 0) {
                                pinSearch = nodeLemma;
                            }
                            else {
                                pinSearch = n.originalLabel;
                            }
                        }

                        // This means the user clicked on the tag or on the graph, so we use that exact parameter to search

                        else {
                            pinSearch = n.originalLabel;
                        }*/

                        pinSearch = n.originalLabel;


                        if (pins.indexOf(pinSearch) > -1) {
                                n.color = '#0089e0';

                            }
                            else {
                                n.color = n.originalColor;

                            }
                            n.label = n.originalLabel;

                    }
                        else  {
                            n.color = deselected_nodes_color;
                            n.label = '';
                        }

                });

                sigma.instances(0).graph.edges().forEach(function(e) {
                        if (toKeepMap[e.source] && toKeepMap[e.target]) {
                            e.color = e.originalColor;
                        }
                        else {
                            e.color = deselected_nodes_color;
                        }
                });



            }

            // No nodes are selected (or all are deselected) - show the whole graph

            else {
                console.log('deselecting the graph');

                sigma.instances(0).graph.nodes().forEach(function(n) {


                   n.color = n.originalColor;
                   n.label = n.originalLabel;

                   n.marked = 0;



                });

                sigma.instances(0).graph.edges().forEach(function(e) {

                   e.color = e.originalColor;

                });

                // Remove all selections
                selectedNodes = [];


                // We show the whole graph above so scroll down to all the statements
                $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);


            }

            // Since the data has been modified, we need to
            // call the refresh method to make the colors
            // update effective.

            sigma.instances(0).refresh();

            <% if (locals.user) { %>
            <% if (locals.user.midi != undefined && locals.user.midi != 'off') { %>


            console.log('using MIDI data ' + midi);
            console.log('playing MIDI device:');
            console.log(output);

            var timecode = 0;

            var note_node = midi.substr(10,2);
            if (note_node.substr(1,1) == '0') {
              note_node = note_node.substr(0,1) + '1';
            }

            var note_edge = midi.substr(12,2);
            if (note_edge.substr(1,1) == '0') {
              note_edge = note_edge.substr(0,1) + '1';
            }



            for (var m = 0; m < pins.length; m++) {


                setTimeout(function () {
                  output.playNote(note_node, parseInt(midi.substr(0,2)));
                  output.stopNote(note_node, parseInt(midi.substr(0,2)), {time: "+500"});
                  console.log('playing a node note ' + note_node + ' at ' + timecode + ' on channel ' + parseInt(midi.substr(0,2)));
                }, timecode);
                timecode = getRandomInt(0,parseInt(midi.substr(6,4)));
            }

            var timecodea = 0;

            for (var ed = 0; ed < toKeep.length; ed++) {

                setTimeout(function () {
                  output.playNote(note_edge, parseInt(midi.substr(2,2)));
                  output.stopNote(note_edge, parseInt(midi.substr(2,2)), {time: "+500"});
                  console.log('playing an edge note ' + note_edge + ' at ' + timecodea + ' on ' + parseInt(midi.substr(2,2)));
                }, timecodea);
                  timecodea = getRandomInt(0,parseInt(midi.substr(6,4)));

            }

            <% } %>
            <% } %>


    }

    // Autofill initialized only after Sigma above loaded and populated all the nodes

    function autofill(nodeNames,contextNames) {

        // console.log(nodeNames);

        $('#statement').textcomplete([
            { // hashtags-concepts
                words: nodeNames,
                match: /\B#(\w*)$/,
                search: function (term, callback) {
                    callback($.map(this.words, function (word) {
                        return word.indexOf(term) === 0 ? word : null;
                    }));
                },
                index: 1,
                replace: function (word) {

                    return '#' + word + ' ';

                }
            },
            { // html
                mentions: contextNames,
                match: /\B@(\w*)$/,
                search: function (term, callback) {
                    callback($.map(this.mentions, function (mention) {
                        return mention.indexOf(term) === 0 ? mention : null;
                    }));
                },
                index: 1,
                replace: function (mention) {
                    return '@' + mention + ' ';
                }
            },
            { // hashtags-concepts
                words: nodeNames,
                match: /\b(\w{2,})$/,
                search: function (term, callback) {
                    callback($.map(this.words, function (word) {
                        return word.indexOf(term) === 0 ? word : null;
                    }));
                },
                index: 1,
                replace: function (word) {

                        return word + ' ';

                }
            }

        ]);





        $('#addcontext').textcomplete([
            { // html
                mentions: contextNames,
                match: /\b(\w{2,})$/,
                search: function (term, callback) {
                    callback($.map(this.mentions, function (mention) {
                        return mention.indexOf(term) === 0 ? mention : null;
                    }));
                },
                index: 1,
                replace: function (mention) {
                    window.open("?addcontext=" + mention, "_self");
                    return '@' + mention + '';
                }
            }
        ]);
    }

    function addTagTriggers() {


        $(".tags").on('click', function(e) {

            e.preventDefault();

            var remove_node = e.target.innerText;

            // Is the clicked node in the pinnedNodes list
            var pinnedIndex = pinnedNodes.indexOf(remove_node);

            // Yes, it is, remove it and push it into the notfoundNodes list

            if (pinnedIndex > -1) {

                    pinnedNodes.splice(pinnedIndex,1);

                  //  notfoundNodes.push(remove_node);

            }


            // TODO this is very fuzzy logic here bad bad

            // Is there any nodes that were clicked before but not displayed on the graph?
            // Yes, more than 1
            if (splicedNodes.length > 1) {
                // Add them into the pinned
                pinnedNodes = [];
                for (var p = 0; p < splicedNodes.length; p++ ){
                    pinnedNodes[p] = splicedNodes[p];
                }
            }


            // Only one
            else if (splicedNodes.length == 1) {
                pinnedNodes = [];
                pinnedNodes[0] = splicedNodes[0];
                splicedNodes = [];
            }


            if (deletedNodes.indexOf(remove_node) > -1) {
                socket.emit('node add', {addingNodes: remove_node, stoplistNodes: deletedNodes});
            }
            else {

            // console.log("node clicked, now will filter for nodes " + pinnedNodes);

                  $('.entry').fadeIn(400);

                  filter_statements(pinnedNodes);


            }





        });

    }

   // Replace hashtags function

    function replaceHashtags(hash){
        var replacementString = $.trim(hash);
        return ' <a href="' + forwardTo + replacementString.substr(1) +'" class="app-concept-link" target="_blank">' + replacementString + '</a>';
    }


    var hashRegex = /(?:\s|^)(?:#(?!\d+(?:\s|$)))(\w+)(?=\s|$)/gi;

    if (link_hashtags) {
        $(".entry").each(function() {
            // Retrieve the statement text from the entry, clean from html
            var originale = $(this).children('.entry-text').html();
            // Replace with hashtags
            $(this).children('.entry-text').html(originale.replace(/#(\w+)/g,  " <a href='" + forwardTo + "$1' class='app-concept-link' target='_blank'>$&</a>"));

        });
    }


    function normalize(enteredValue, minEntry, maxEntry, normalizedMin, normalizedMax) {
      var mx;
      if ((enteredValue-minEntry) == 0) { mx = 0 } else {
        mx = (Math.log1p((enteredValue-minEntry))/(Math.log1p(maxEntry-minEntry)));
      }
      var preshiftNormalized = mx*(normalizedMax-normalizedMin);
      var shiftedNormalized = preshiftNormalized + normalizedMin;

      return shiftedNormalized;

    }

    function shannon(data) {

        // Create a dictionary of character frequencies and iterate over it.
      function process(s, evaluator) {
          var h = Object.create(null), k;
          s.split('').forEach(function(c) {
            h[c] && h[c]++ || (h[c] = 1); });
          if (evaluator) for (k in h) evaluator(k, h[k]);
          return h;
        };

      // Measure the entropy of a string in bits per symbol.

      // Measure the entropy of a string in total bits.
      function bits (s) {
        return entropy(s) * s.length;
      }


      var sum = 0,len = data.length;
      process(data, function(k, f) {
         var p = f/len;
         sum -= p * Math.log(p) / Math.log(2);
      });

      return sum;

    }

    setTimeout(function() {
      if (localStorage.getItem("selections")) {

          var saved_selections = JSON.parse(localStorage.getItem("selections"));

          if (saved_selections[window.location.href]) {
            deletedNodes = saved_selections[window.location.href].stopnodes;
            pinnedNodes = saved_selections[window.location.href].pinnednodes;
            if (deletedNodes.length > 0) {
              socket.emit('node delete', {pinnedNodes: deletedNodes, delete_from: "localstorage"});
            }
            else {
              if (pinnedNodes.length > 0) {
                filter_statements(pinnedNodes);
              }
            }



          }
          else if (interpret) {
            console.log(saved_selections);
            for (var boom in saved_selections) {
              if (boom.indexOf('/'+addcontext+'/') > -1) {
                deletedNodes = saved_selections[boom].stopnodes;
                pinnedNodes = saved_selections[boom].pinnednodes;
                console.log(deletedNodes);
                console.log(pinnedNodes);
                if (deletedNodes.length > 0) {
                  socket.emit('node delete', {pinnedNodes: deletedNodes, delete_from: "localstorage"});
                }
                else {
                  if (pinnedNodes.length > 0) {
                    filter_statements(pinnedNodes);
                  }
                }
              }
            }
          }
          else if (selected_keywords && selected_keywords.length > 0) {
            pinnedNodes = selected_keywords.split("+");


              if (pinnedNodes.length > 0) {
                filter_statements(pinnedNodes);
              }


          }

      }
      // TODO clear that
      else if (selected_keywords && selected_keywords.length > 0) {
        pinnedNodes = selected_keywords.split("+");


          if (pinnedNodes.length > 0) {
            filter_statements(pinnedNodes);
          }


      }

      downloadPNG();

    }, 3000);

    // TODO above is ridiculously bad - fix this timing issue

    //downloadPNG();
    // Download PNG (the graph isn't modified)
    function downloadPNG() {
      var canvaspng = document.querySelector('.sigma-scene');

      document.querySelector('#downloadpng').href = canvaspng.toDataURL();
      document.querySelector('#downloadpng').download = current_user + '_' + current_context + '.png';

      document.querySelector('#downloadpng').addEventListener('click', function(ev) {
        document.querySelector('#downloadpng').href = canvaspng.toDataURL();
        document.querySelector('#downloadpng').download = current_user + '_' + current_context + '.png';
      }, false);

    }



})();
</script>




<% include statsbelow %>
</body>
</html>
