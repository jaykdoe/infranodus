<div id="entryform" class="editorpane">
    <%- include('./Header',
        {perceivername, addcontext, context}); %>

    <%- include('./Footer',
        {perceivername, context, contextpublic}); %>

        <!-- the panel to show content -->
    <%- include('./Body',
        {perceivername, url, urltitle}); %>
</div>

<script>

// Who posted the entry?
var selfPosted = null;


var mute = getUrlVars()["mute"];

var currentStatementSidePanelMode = "EDIT"

if (viewType == 'external') {    
    currentStatementSidePanelMode = "SEARCH"
}

changeModeTo(currentStatementSidePanelMode);

function updateStatementSidePanel() {
    if(currentStatementSidePanelMode === "EDIT") switchToEdit()
    if(currentStatementSidePanelMode === "SEARCH") switchToSearch()
   
}

function switchToSearch() {
    switchStatementMenu('finds');
    sidePanelContent().hide('#edit-panel');
    sidePanelContent().show('#search-panel');
    searchForm().autofill();
    changeEntriesHeight(200)
    hideFooter()
}

function switchToEdit() {
    if (viewType != 'external') {
        switchStatementMenu('adds');
        sidePanelContent().hide('#search-panel');
        sidePanelContent().show('#edit-panel');
        // TODO: get the logic from entries.ejs starting from (topmenuaction == 'adds') {
        changeEntriesHeight(400)
        showFooter()    
    }
}

function switchToInterpret() {
    // create a new graph
    // add the current (old) context
    // add interpretation functionality 
        // a. remove all visible entries from the "old" context
        // b. switch the way both graph intersection is colored
    // open the page with the parameters above
    navigation().redirect('');
}

function changeEntriesHeight(height) {
    entries().fillSpace(height);
}

function changeSidePanelHeight(height) {
    sidePanel().resize(height);
}

function switchStatementMenu(element) {
    statementMenu().switch(element);
}

function hideFooter(){
    deleteContextButton().hide()
    privacyLinkButton().hide()
    collaborateButton().hide();
    importLinkButton().hide();
}

function showFooter(){
    deleteContextButton().show()
    privacyLinkButton().show()
    collaborateButton().show();
    importLinkButton().show();
}

function changeModeTo(mode) {
    currentStatementSidePanelMode = mode
    updateStatementSidePanel()
}

function sendToImport() {
    var fornode = $('#statement').val();
    if (pinnedNodes.length > 0) {
        fornode = pinnedNodes.join("+");
    }
    navigation().redirect('/import?context=' + current_context + '&fornode=' + fornode);
}

function changeModeToSearch() {changeModeTo('SEARCH')}
function changeModeToEdit() {changeModeTo('EDIT')}
function changeModeToInterpret() {changeModeTo('INTERPRET')}
function togglePanel() {
    if (currentStatementSidePanelMode === 'SEARCH') {
        currentStatementSidePanelMode = 'EDIT'
    }
    else if (currentStatementSidePanelMode === 'EDIT') {
        currentStatementSidePanelMode = 'SEARCH';
    }
    changeModeTo(currentStatementSidePanelMode);
}

findsButton().onClick(changeModeToSearch);
editButton().onClick(changeModeToEdit);
interpretButton().onClick(changeModeToInterpret);
minimizeButton().onClick(togglePanel);
closeStatementMenuButton().onClick(hideStatements);
importLinkButton().onClick(sendToImport);


function sidePanelContent() {
    return {
        show: function(element){
            $(element).show();
        },
        hide: function(element){
            $(element).hide();
        }
    }
}

function hideStatements() {
    toggleStatementSidePanel();
}

// Here we add onClick event for the entry add form after it's loaded. 
// TODO move it out into a function

submitFormProcess();


// OnLoad get the right height for the entries elements — this depends on the form so it's here

var uproll = $('#entryform').height();

if (hide_edit) {
  uproll = 50;
}

entries().fillSpace(uproll + 100);

// Scroll down all the entries

entries().scroll();

// Do the same with when the window is resized 

$(window).resize(function() {
    entries().fillSpace(uproll + 100);
    entries().scroll();
});

// Make texarea automatically resizeable
$('textarea').autosize();




// Here we perform some live updates of the graph on receiving a Socket.IO message
// We could also move this code and use sigma.instances(0).graph.nodes() to get sigma properties

// TODO set up chatroom, make better design, think of graph sharing functionality

socket.on('chat message', function(msg){

    visibleentries_original = visibleentries_original + 1;

    var perceivedby = '';

    <% if (receivername) { %>
    perceivedby = '<%= receivername %>';
    <% } %>

    var posted_by = msg.postedby;

    var added_entry =  "<div class='entry' style='display: none;' data-uid='" + msg.entryuid + "' data-hashtags='" + msg.entryname + "'><p class='entry-text'>" + msg.entrytext + "</p><p class='entry-date'>by " + posted_by + " at " + moment().format('hh:mm:ss') + "</p><div class='separator'>&nbsp;</div><div id='" + msg.entryuid + "' class='hidden'></div></div>";

    // if the message is not self-posted and also if the poster of the message is not the same as the guy logged in (in case there's two logins simultaneously)
    if (!selfPosted && perceivedby != posted_by) {
        // add the alien class so the posted message looks like it's from elsewhere
        added_entry =  "<div class='entry alien' style='display: none; margin-left: 50px' data-uid='" + msg.entryuid + "'><p class='entry-text gray'>" + msg.entrytext + "</p><p class='entry-date gray'>by " + posted_by + " at " + moment().format('hh:mm:ss') + "</p><div class='separator'>&nbsp;</div><div id='" + msg.entryuid + "' class='hidden'></div></div>";

        if (msg.help) {
            added_entry =  "<div class='entry alien' style='display: none; margin-left: 50px' data-uid='" + msg.entryuid + "'><p class='entry-text gray'>" + msg.entrytext + "</p><p class='entry-date gray'>help tip &nbsp;<em></em><a href='javascript:' class='disablehelp'>disable</a></em></p><div class='separator'>&nbsp;</div><div id='" + msg.entryuid + "' class='hidden'></div></div>";
        }

        // We will set a user for receiving. If the posting user does not equal the user who's watching the graph, we force-add the statement into theirs (provided they collaborate)
        var receivedby = '';

        <% if (perceivername) { %>
            receivedby = '<%= perceivername %>';
        <% } %>

        // TODO make it possible that those statements get submitted in both graphs

        // So the user who posted is not the same who's receiving? then submit the form. If the sender didnt have the mute option
        // This is only for collaboration - we resubmit, otherwise it's already submitted before
        if ((receivedby != msg.postedby) && !msg.mute) {


            /*var temporary_statement = $('#statement').val();
            $('#statement').val(msg.entrytext);
            console.log($("#submitform").serialize());*/

            var to_submit = $('#submitform').serializeArray();

            for (key in to_submit) {
                if (to_submit[key].name == 'entry[body]') {
                    to_submit[key].value = msg.entrytext;
                }
            }

            $.post('/post', $.param(to_submit))
                    .done(function(res) {

            /*          $('#statement').val(temporary_statement);*/

                        //3. Receive the server response, no need to emit an event
                        if (res.entryuid) {
                            //4. Show the updated text

                            if (res.entryuid == 'multiple') {
                            if (res.successmsg) {
                                $("#warnings").append('<p class="warning">Your collaborator submitted a long text. Please, reload the page to see the graph.</p>');
                                $("#warnings").slideDown('slow');
                            }
                            setTimeout(function() {
                                location.reload();
                            },3000);
                            }
                        }
                        else if (res.errormsg) {
                            alert(res.errormsg);
                        }
                        else {
                            alert('Something went wrong, please, try again...');
                        }
                    })
                    .fail(function(res) {
                        alert("Server Error: " + res.status + " " + res.statusText);
                    });

        }



    }
    else {
        selfPosted = null;
    }

    // So let's add that entry to the #entries DIV

    $(added_entry).appendTo($('#entries')).slideDown("fast");

    // Do some stupid class change for the dark theme background
    if (background == 'dark') {
    $('.entry').addClass('entry-dark');
    $('.entry-text').addClass('entry-text-dark');
    }
    // Nicely scroll







    //$('#entries').append(added_entry).slideUp("fast");

    // Unfocus and reFocus again on the entry field
    $('#statement').blur();
    $('#statement').focus();


    // Add some behavior hooks again onto that element
    // One click will filter the nodes / edges of the statement on the graph
    // Doubleclick will open the edit pane

    entryClick();
    entryDoubleClick();


    adding_entry = true;
    if (dynamic_watch == 1 && dynamic_graph == 1) {
      $('#watch-link').trigger('click');
      setTimeout(function() {
        entries().scroll();
      }, 500);
      setTimeout(function() {
        adding_entry = false;
        $('#watch-link').trigger('click');
      }, 4000);
    }
    else {
        entries().scroll();
    }

    var addednodes = msg.graph.nodes;
    var addededges = msg.graph.edges;

    var nodes_added = [];
    var edges_added = [];


    // Let's add the nodes to the Sigma graph
    for (var i = 0; i < addednodes.length; i++) {

        if (nodeNames.indexOf(addednodes[i].label) == -1) {

           // var angle = Math.PI * 2 * i / len;

            sigma.instances(0).graph.addNode({
                id: (id = addednodes[i].id),
                label: addednodes[i].label,
                originalLabel: addednodes[i].label,
                originalColor: color_context,
                size: maxnodesize - 2,
                x: Math.random(),
                y: Math.random(),
                color: color_context
            });
            nodeNames.push(addednodes[i].label);
            nodes_added.push(addednodes[i]);
            if (!nodeIDs[addednodes[i].label]) {
              nodeIDs[addednodes[i].label] = addednodes[i].id;
            }


        }


    }

    // Let's add the edges to the Sigma graph

    for (var j = 0; j < addededges.length; j++) {

       if ((addededges[j].statement_id == msg.entryuid)) {


         var unique_edge_id = '';

         // Let's see if the edge source in alphabetical order is further than its target and change places

         if (addededges[j].source > addededges[j].target) {
             unique_edge_id = addededges[j].target + '-' + addededges[j].source;
         }
         else {
             unique_edge_id = addededges[j].source + '-' + addededges[j].target;
         }


            sigma.instances(0).graph.addEdge({
                id: addededges[j].id,
                source: addededges[j].source,
                target: addededges[j].target,
                weight: addededges[j].weight,
                size: addededges[j].weight,
                statement_id: addededges[j].statement_id,
                edge_context: addededges[j].edge_context
            });

            edges_added.push(addededges[j]);


        }

    }

    // Let's create a new collection for Cytoscape - used to calculate node metrics for the graph
    var collection = cy.elements();
    cy.remove(collection);

    elesnodes = [];

    // Adding all the refreshed nodes into Cytoscape
    sigma.instances(0).graph.nodes().forEach(function(n) {
        if (n.id == 'dummy') {
            sigma.instances(0).graph.dropNode('dummy');
        }
        else {

          // Add to Cytoscape
          elesnodes.push({
              group: "nodes",
              data: { id: n.id, name: n.label}
          });

        }

      //n.size = sigma.instances(0).graph.degree(n.id);

    });

    // For each edge in the graph recalculate some important metrics
    // And update global parameters which we use to track the state of each element
    // TODO this code duplicates from above - move into a function

    // jsnetworkx
    var jsGraphEdges = [];
    nodeIDs_rev = _.invert(nodeIDs);

    sigma.instances(0).graph.edges().forEach(function(e) {

      var unique_edge_id = '';

      // Let's see if the edge source in alphabetical order is further than its target and change places

      if (e.source > e.target) {
          unique_edge_id = e.target + '-' + e.source;
      }
      else {
          unique_edge_id = e.source + '-' + e.target;
      }


        // Make and index of nodes to statement

          if (nodesOfStatement[e.statement_id]) {
              if (nodesOfStatement[e.statement_id].indexOf(e.source) < 0)
                  nodesOfStatement[e.statement_id].push(e.source);
              if (nodesOfStatement[e.statement_id].indexOf(e.target) < 0)
                  nodesOfStatement[e.statement_id].push(e.target);
          }
          else {
              nodesOfStatement[e.statement_id] = [];
              nodesOfStatement[e.statement_id].push(e.source);
              nodesOfStatement[e.statement_id].push(e.target);
          }

        // Which statements belong to which context / graph
        if (statementsOfContext[e.edge_context]) {
              if (statementsOfContext[e.edge_context].indexOf(e.statement_id[0]) < 0) {
                statementsOfContext[e.edge_context].push(e.statement_id[0]);
              }
        }
        else {
            statementsOfContext[e.edge_context] = [];
            statementsOfContext[e.edge_context].push(e.statement_id[0]);
        }


                        // Make an index of nodes to context
                        if (contextNodeID[e.edge_context]) {
                            if (contextNodeID[e.edge_context].indexOf(e.source) < 0)
                                contextNodeID[e.edge_context].push(e.source);
                            if (contextNodeID[e.edge_context].indexOf(e.target) < 0)
                                contextNodeID[e.edge_context].push(e.target);
                        }
                        else {
                            contextNodeID[e.edge_context] = [];
                            contextNodeID[e.edge_context].push(e.source);
                            contextNodeID[e.edge_context].push(e.target);
                        }


        // Add to Cytoscape for betweenness centrality calculation
        elesnodes.push({
            group: "edges",
            data: { id: unique_edge_id, source: e.source, target: e.target, weight: e.weight }
        });

        // TODO remove that, this is just to check data consistentency
        e.sourcename = nodeIDs_rev[e.source];
        e.targetname = nodeIDs_rev[e.target];

        // Add to jsnetworkx

        var edge_params = {
                     weight: 1/e.weight,
                     sourcename: e.sourcename,
                     targetname: e.targetname                     
        };

        var edge_object = [e.source, e.target, edge_params];
                 
        jsGraphEdges.push(edge_object);


    });


    // Betweenness Centrality Calculation using Cytoscape
    eless = cy.add(elesnodes);

    var jsG = new jsnx.DiGraph();
    // jsG = jsnx.convertToUndirected(jsG);
           
    jsG.addEdgesFrom(jsGraphEdges);

    // console.log(eles.nodes().length);

    betweennessCentrality(eless, jsG);
    communityDetect();

    //sigma.refresh();

    // Launch new layout
    if (forcedatlas_running) {
      $('#improve-layout').trigger('click');
      setTimeout(function() {
        $('#improve-layout').trigger('click');
      }, 500);
    }
    else {
      sigma.instances(0).startForceAtlas2(forceatlas_options);
      setTimeout(function() {

          sigma.instances(0).stopForceAtlas2();
          sigma.instances(0).killForceAtlas2();

      }, 3000);
    }

    // MIDI activation

    // Play a note on adding nodes / edges

    <% if (locals.user) { %>
    <% if (locals.user.midi != undefined && locals.user.midi != 'off') { %>


    console.log('using MIDI data ' + midi);
    console.log('playing MIDI device:');
    console.log(output);

    var timecode = 0;

    var note_node = midi.substr(10,2);
    if (note_node.substr(1,1) == '0') {
      note_node = note_node.substr(0,1) + '1';
    }

    var note_edge = midi.substr(12,2);
    if (note_edge.substr(1,1) == '0') {
      note_edge = note_edge.substr(0,1) + '1';
    }



    for (var m = 0; m < nodes_added.length; m++) {


        setTimeout(function () {
          output.playNote(note_node, parseInt(midi.substr(0,2)));
          output.stopNote(note_node, parseInt(midi.substr(0,2)), {time: "+500"});
          console.log('playing a node note ' + note_node + ' at ' + timecode + ' on channel ' + parseInt(midi.substr(0,2)));
        }, timecode);
        timecode = getRandomInt(0,parseInt(midi.substr(6,4)));
    }

    var timecodea = 0;

    for (var ed = 0; ed < edges_added.length; ed++) {

        setTimeout(function () {
          output.playNote(note_edge, parseInt(midi.substr(2,2)));
          output.stopNote(note_edge, parseInt(midi.substr(2,2)), {time: "+500"});
          console.log('playing an edge note ' + note_edge + ' at ' + timecodea + ' on ' + parseInt(midi.substr(2,2)));
        }, timecodea);
          timecodea = getRandomInt(0,parseInt(midi.substr(6,4)));

    }

    <% } %>
    <% } %>




    //console.log(newnodes);
    // console.log(msg.graph.edges);
    // console.log(sigma.instances(0).graph.edges());

    // TODO right now it doubles the code above

    // This is for special cases where the user is on a graph, but they are adding their own stuff to this graph into a new graph, so we only show the entries that he added, not the previous ones
    if (addcontext && interpret) {

      $('.entry').hide();

      for (var ite in statementsOfContext[current_context]) {

        $('.entry[data-uid="' + statementsOfContext[current_context][ite] + '"]').each(function() {
          $(this).show();
        });

      }


  }


});



// What do do when the form is submitted and a new entry (text) is added?

function submitFormProcess() {

    document.querySelector('#submitform').addEventListener('submit', function(e) {

        e.preventDefault();

        $('#statement').addClass('loading');

        $('#submitbutton').attr('disabled', 'disabled');

        if ($('#livetext').html().length > 0 && voice_continues) {
        $('#livetext').html($('#statement').val() + '<br><em>saving into the graph...</em><span></span>');
        setTimeout(function(){
            $('#livetext').html('<em>waiting...</em>' + ' <span></span>');
        }, 3000);
        }

        // We will set a user for posting. If the posting user does not equal the user who's watching the graph, we force-add the statement into theirs (provided they collaborate)
        var postedby = '';

        <% if (receivername) { %>
        postedby = '<%= receivername %>';
        <% } %>
        // TODO make it possible that those statements get submitted in both graphs

        // is urlvars mute off? then post as usual
        if (!mute) {
        $.post('/post', $("#submitform").serialize())
                .done(function(res) {
                    //3. Receive the server response, no need to emit an event
                    if (res.entryuid) {
                        //4. Show the updated text
                        selfPosted = '1';
                        $("#statement").val('');
                        $('#statement').removeClass('loading');
                        $('#submitbutton').removeAttr('disabled');

                        // This below if a few statements were posted
                        // TODO as we can now get all the s.uid back as an array this could be rewritten so no need for the condition after
                        if (res.entryuid == 'multiple') {
                            socket.emit('chat message', {postedby: postedby, entryuid: 'multiplesocket', entrytext: res.entrycontent, graph: res.graph});
                            if (res.successmsg) {
                            $("#warnings").append('<p class="warning">Please, reload the page after a few seconds to see the graph.</p>');
                            $("#warnings").slideDown('slow');
                            }
                            setTimeout(function() {
                                location.reload();
                            },3000);
                        }
                        else {
                            // Only one statement added? Initiate processing that will show it both to the user and the collaborator (if exists)
                            socket.emit('chat message', {postedby: postedby, entryuid: JSON.parse(res.entryuid).data, entrytext: res.entrytext, graph: res.graph});
                        }

                    }
                    else if (res.errormsg) {
                        $('#statement').removeClass('loading');
                        $('#submitbutton').removeAttr('disabled');
                        alert(res.errormsg);
                    }
                    else {
                        alert('Something went wrong, please, try again...');
                    }
                })
                .fail(function(res) {
                    alert("Server Error: " + res.status + " " + res.statusText);
                });

        }
        // otherwise - make a dummy post - it appears in the list but doesn't get submitted into the graph
        // This was made before to introduce a chat feature — so the software can "talk" to the user without adding stuff into the graph
        else {
            selfPosted = '1';
            $('#statement').removeClass('loading');
            $('#submitbutton').removeAttr('disabled');
            $("#statement").val('');
            socket.emit('chat message', {mute: 1, postedby: postedby, entryuid: '', entrytext: $('#statement').val(), graph: ''});
        }

        return false;
    });


    $('#statement').keypress(function(e){

        // Submit the form on enter

        if(e.which == 13 && !e.shiftKey) {
            e.preventDefault();
            $('#submitbutton').trigger('click');
        }

    });

}


</script>